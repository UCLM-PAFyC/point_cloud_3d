# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PointCloudToolsDockWidget
                                 A QGIS plugin
 A plugin for manage point clouds from LIDAR or photogrammetry
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-02-08
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Universidad de Castilla-La Mancha
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# dhl
import sys,os
from math import sqrt,ceil
from osgeo import osr
from decimal import Decimal
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QFileInfo, QDir, QObject
from PyQt5.QtWidgets import QMessageBox,QFileDialog,QTabWidget,QInputDialog,QLineEdit
from qgis.core import QgsApplication, QgsDataSourceUri
# pluginsPath = QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path()
# pluginPath = os.path.dirname(os.path.realpath(__file__))
# pluginPath = os.path.join(pluginsPath, pluginPath)
# libCppPath = os.path.join(pluginPath, 'libCpp')
# existsPluginPath = QDir(libCppPath).exists()
# sys.path.append(pluginPath)
# sys.path.append(libCppPath)
# os.environ["PATH"] += os.pathsep + libCppPath
# from libCpp.libPyPointCloudTools import IPyPCTProject
# from multipleFileSelectorDialog.multiple_file_selector_dialog import * #panel nueva camara
# from processListEditionDialog.process_list_edition_dialog import *
# import PCTDefinitions

from .multipleFileSelectorDialog.multiple_file_selector_dialog import * #panel nueva camara
from .processListEditionDialog.process_list_edition_dialog import *
from . import PCTDefinitions
#  dhl

from PyQt5 import QtGui, QtWidgets, uic
from PyQt5.QtCore import pyqtSignal,QSettings
from PyQt5.QtWidgets import QTextEdit,QPushButton,QVBoxLayout


from .selectionMapTools.rectangle_map_tool import RectangleMapTool
from .selectionMapTools.polygon_map_tool import PolygonMapTool
from .selectionMapTools.freehand_map_tool import FreehandMapTool


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'point_cloud_tools_dockwidget_base.ui'))

class TextEditDialog(QDialog):
    def __init__(self, parent=None):
        super(TextEditDialog, self).__init__(parent)
        # Create widgets
        self.setWindowTitle("Edit value")
        self.qTextEdit = QTextEdit()
        self.setMinimumSize(QSize(440, 240))
        #self.button = QPushButton("Show Greetings")
        # Create layout and add widgets
        layout = QVBoxLayout()
        layout.addWidget(self.qTextEdit)
        self.acceptButton = QPushButton()
        self.acceptButton.setText("Accept")
        self.acceptButton.setMaximumWidth(80)
        layout.addWidget(self.acceptButton,0,Qt.AlignRight)
        self.acceptButton.clicked.connect(self.dialogAccept)
        #layout.addWidget(self.button)
        # Set dialog layout
        self.setLayout(layout)
        self.accepted = False
        # Add button signal to greetings slot
        #self.button.clicked.connect(self.greetings)
    # Greets the user

    def dialogAccept(self):
        self.accepted = True
        self.accept()

    def setValue(self,value):
        self.qTextEdit.setText(value)

    def getValue(self):
        value = None
        if self.accepted:
            value = self.qTextEdit.toPlainText()
        return value

class PointCloudToolsDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self,
                 iface,
                 pluginPath,
                 libCppPath,
                 currentPluginName,
                 settings,
                 iPyProject,
                 connectionFileName,#WithoutPath,
                 # modelManagementFileName,
                 parent=None):
        """Constructor."""
        super(PointCloudToolsDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setWindowTitle(PCTDefinitions.CONST_PROGRAM_NAME)
        self.iface = iface
        self.path_plugin = pluginPath
        self.path_libCpp = libCppPath
        self.current_plugin_name = currentPluginName
        self.settings = settings
        self.iPyProject = iPyProject
        self.isPCTPlugin = False
        if self.current_plugin_name == PCTDefinitions.CONST_SETTINGS_PLUGIN_NAME:
            self.isPCTPlugin = True
        self.setupUi(self)
        self.connectionFileName = connectionFileName
        # self.modelManagementFileName= modelManagementFileName
        self.initialize()

    def actionSetVisiblePoints(self):
        for tileTableName in self.loadedTiles:
            layerList = QgsProject.instance().mapLayersByName(tileTableName)
            if len(layerList) == 1:
                vlayer = layerList[0]
                ltm = self.iface.layerTreeView().model()
                lsi = vlayer.renderer().legendSymbolItems()
                for classNumber in self.lavelSimbolByClassNumber:
                    className = self.lavelSimbolByClassNumber[classNumber]
                    ruleKey = [l.ruleKey() for l in lsi if l.label() == className]
                    # if ruleKey:
                    if not classNumber in self.visibleCheckBoxByClassNumber: # por la clase 8
                        continue
                    checkBox = self.visibleCheckBoxByClassNumber[classNumber]
                    if checkBox.isChecked():
                        ltm.findLegendNode(vlayer.id(), ruleKey[0]).setData(Qt.Checked, Qt.CheckStateRole)
                    else:
                        ltm.findLegendNode(vlayer.id(), ruleKey[0]).setData(Qt.Unchecked, Qt.CheckStateRole)
                self.iface.layerTreeView().refreshLayerSymbology(vlayer.id())
        return

    def actionWithSelectedPoints(self,classValue):
        [selectedPointsIdByTableName,numberOfSelectedPoints] = self.getSelectedPointsIdByTableName()
        if numberOfSelectedPoints == 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select at least one point")
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        if self.lockedClass0CheckBox.isChecked():
            self.lockedClasses[0] = True
        else:
            self.lockedClasses[0] = False
        if self.lockedClass1CheckBox.isChecked():
            self.lockedClasses[1] = True
        else:
            self.lockedClasses[1] = False
        if self.lockedClass2CheckBox.isChecked():
            self.lockedClasses[2] = True
        else:
            self.lockedClasses[2] = False
        if self.lockedClass3CheckBox.isChecked():
            self.lockedClasses[3] = True
        else:
            self.lockedClasses[3] = False
        if self.lockedClass4CheckBox.isChecked():
            self.lockedClasses[4] = True
        else:
            self.lockedClasses[4] = False
        if self.lockedClass5CheckBox.isChecked():
            self.lockedClasses[5] = True
        else:
            self.lockedClasses[5] = False
        if self.lockedClass6CheckBox.isChecked():
            self.lockedClasses[6] = True
        else:
            self.lockedClasses[6] = False
        if self.lockedClass7CheckBox.isChecked():
            self.lockedClasses[7] = True
        else:
            self.lockedClasses[7] = False
        # if self.lockedClass8CheckBox.isChecked():
        #     self.lockedClasses[8] = True
        # else:
        #     self.lockedClasses[8] = False
        if self.lockedClass9CheckBox.isChecked():
            self.lockedClasses[9] = True
        else:
            self.lockedClasses[9] = False
        # if self.lockedClass10CheckBox.isChecked():
        #     self.lockedClasses[10] = True
        # else:
        #     self.lockedClasses[10] = False
        # if self.lockedClass11CheckBox.isChecked():
        #     self.lockedClasses[11] = True
        # else:
        #     self.lockedClasses[11] = False
        # if self.lockedClass12CheckBox.isChecked():
        #     self.lockedClasses[12] = True
        # else:
        #     self.lockedClasses[12] = False
        # if self.lockedClass13CheckBox.isChecked():
        #     self.lockedClasses[13] = True
        # else:
        #     self.lockedClasses[13] = False

        if self.changeClassRadioButton.isChecked():
            ret = self.iPyProject.pctChangeClassToSelectedPoints(self.dbFileName,
                                                                 selectedPointsIdByTableName,
                                                                 classValue,
                                                                 self.lockedClasses)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            if not self.storePointsData:
                for tileTableName in selectedPointsIdByTableName:
                    layerList = QgsProject.instance().mapLayersByName(tileTableName)
                    if len(layerList) == 1:
                        vlayer = layerList[0]
                        vlayer.startEditing()
                        features = vlayer.selectedFeatures()
                        changePoints = False
                        for feature in features:
                            # pointId = feature[PCTDefinitions.CONST_LAYER_PCTILES_FIELD_ID_NAME]
                            pointNewClass = feature["class_new"]
                            if feature["removed"]:
                                continue
                            if pointNewClass in self.lockedClasses:
                                if self.lockedClasses[pointNewClass]:
                                    continue
                            feature.setAttribute("class_new", classValue)
                            vlayer.updateFeature(feature)
                            changePoints = True
                        vlayer.commitChanges()
                        if changePoints:
                            vlayer.triggerRepaint()
        if self.selectOnlyRadioButton.isChecked():
            ret = self.iPyProject.pctSelectOnlyOnSelectedPoints(self.dbFileName,
                                                                selectedPointsIdByTableName,
                                                                classValue,
                                                                self.lockedClasses)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            newSelectedPointsIdByTableName = {}
            nrow = -1
            for row in ret:
                nrow = nrow + 1
                if nrow == 0:
                    continue
                tableName = ret[nrow][0]
                ncol = -1
                pointsId = []
                for col in ret[nrow]:
                    ncol = ncol + 1
                    if ncol == 0:
                        continue
                    pointsId.append(ret[nrow][ncol])
                newSelectedPointsIdByTableName[tableName] = pointsId
            self.selectedPointsIdByTableName(newSelectedPointsIdByTableName)
        if self.unselectRadioButton.isChecked():
            ret = self.iPyProject.pctUnselectOnSelectedPoints(self.dbFileName,
                                                              selectedPointsIdByTableName,
                                                              classValue,
                                                              self.lockedClasses)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            newSelectedPointsIdByTableName = {}
            nrow = -1
            for row in ret:
                nrow = nrow + 1
                if nrow == 0:
                    continue
                tableName = ret[nrow][0]
                ncol = -1
                pointsId = []
                for col in ret[nrow]:
                    ncol = ncol + 1
                    if ncol == 0:
                        continue
                    pointsId.append(ret[nrow][ncol])
                newSelectedPointsIdByTableName[tableName] = pointsId
            self.selectedPointsIdByTableName(newSelectedPointsIdByTableName)
        if self.removeRadioButton.isChecked():
            if not classValue:
                classValue = -1
            ret = self.iPyProject.pctRemoveSelectedPoints(self.dbFileName,
                                                          selectedPointsIdByTableName,
                                                          classValue,
                                                          self.lockedClasses)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            if not self.storePointsData:
                for tileTableName in selectedPointsIdByTableName:
                    layerList = QgsProject.instance().mapLayersByName(tileTableName)
                    if len(layerList) == 1:
                        vlayer = layerList[0]
                        vlayer.startEditing()
                        features = vlayer.selectedFeatures()
                        changePoints = False
                        for feature in features:
                            pointId = feature[PCTDefinitions.CONST_LAYER_PCTILES_FIELD_ID_NAME]
                            if feature["removed"]:
                                continue
                            pointNewClass = feature["class_new"]
                            if pointNewClass in self.lockedClasses:
                                if self.lockedClasses[pointNewClass]:
                                    continue
                            if classValue == -1:# todas las clases
                                feature.setAttribute("removed", True)
                                pointClass = feature["class"]
                                feature.setAttribute("class_new", pointClass)
                                vlayer.updateFeature(feature)
                                changePoints = True
                            else:
                                if pointNewClass == classValue:
                                    feature.setAttribute("removed", True)
                                    pointClass = feature["class"]
                                    feature.setAttribute("class_new", pointClass)
                                    vlayer.updateFeature(feature)
                                    changePoints = True
                        vlayer.commitChanges()
                        if changePoints:
                            vlayer.triggerRepaint()
        if self.recoverRadioButton.isChecked():
            if not classValue:
                classValue = -1
            ret = self.iPyProject.pctRecoverSelectedPoints(self.dbFileName,
                                                           selectedPointsIdByTableName,
                                                           classValue,
                                                           self.lockedClasses)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            if not self.storePointsData:
                for tileTableName in selectedPointsIdByTableName:
                    layerList = QgsProject.instance().mapLayersByName(tileTableName)
                    if len(layerList) == 1:
                        vlayer = layerList[0]
                        vlayer.startEditing()
                        features = vlayer.selectedFeatures()
                        changePoints = False
                        for feature in features:
                            pointId = feature[PCTDefinitions.CONST_LAYER_PCTILES_FIELD_ID_NAME]
                            if not feature["removed"]:
                                continue
                            pointNewClass = feature["class_new"]
                            if pointNewClass in self.lockedClasses:
                                if self.lockedClasses[pointNewClass]:
                                    continue
                            if classValue == -1:  # todas las clases
                                feature.setAttribute("removed", False)
                                # pointClass = feature["class"] # porque si lo habia eliminado ya class_new = class
                                # feature.setAttribute("class_new", pointClass)
                                vlayer.updateFeature(feature)
                                changePoints = True
                            else:
                                if pointNewClass == classValue:
                                    feature.setAttribute("removed", False)
                                    # pointClass = feature["class"] # porque si lo habia eliminado ya class_new = class
                                    # feature.setAttribute("class_new", pointClass)
                                    vlayer.updateFeature(feature)
                                    changePoints = True
                        vlayer.commitChanges()
                        if changePoints:
                            vlayer.triggerRepaint()
        if self.toOriginalClassRadioButton.isChecked():
            if not classValue:
                classValue = -1
            ret = self.iPyProject.pctToOriginalClassSelectedPoints(self.dbFileName,
                                                                   selectedPointsIdByTableName,
                                                                   classValue,
                                                                   self.lockedClasses)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            if not self.storePointsData:
                for tileTableName in selectedPointsIdByTableName:
                    layerList = QgsProject.instance().mapLayersByName(tileTableName)
                    if len(layerList) == 1:
                        vlayer = layerList[0]
                        vlayer.startEditing()
                        features = vlayer.selectedFeatures()
                        changePoints = False
                        for feature in features:
                            # pointId = feature[PCTDefinitions.CONST_LAYER_PCTILES_FIELD_ID_NAME]
                            pointNewClass = feature["class_new"]
                            if feature["removed"]:
                                continue
                            if classValue != -1:  # todas las clases
                                if pointNewClass != classValue:
                                    continue
                            if pointNewClass in self.lockedClasses:
                                if self.lockedClasses[pointNewClass]:
                                    continue
                            pointClass = feature["class"]
                            feature.setAttribute("class_new", pointClass)
                            vlayer.updateFeature(feature)
                            changePoints = True
                        vlayer.commitChanges()
                        if changePoints:
                            vlayer.triggerRepaint()
        return

    def addProcessToList(self):
        crs = self.ppToolsIPCFsQgsProjectionSelectionWidget.crs()
        isValidCrs = crs.isValid()
        crsAuthId = crs.authid()
        if not "EPSG:" in crsAuthId:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not EPSG")
            msgBox.exec_()
            return
        crsEpsgCode = int(crsAuthId.replace('EPSG:',''))
        crsOsr = osr.SpatialReference()  # define test1
        if crsOsr.ImportFromEPSG(crsEpsgCode) != 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error importing OSR CRS from EPSG code" + str(crsEpsgCode))
            msgBox.exec_()
            return
        if not crsOsr.IsProjected():
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not a projected CRS")
            msgBox.exec_()
            return
        altitudeIsMsl = True
        if self.ppToolsIPCFsAltitudeEllipsoidRadioButton.isChecked():
            altitudeIsMsl = False
        inputFiles = self.postprocessingIPCFs
        if len(inputFiles ) == 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select input files")
            msgBox.exec_()
            return
        outputFile = self.ppToolsOPCFsOutputFileLineEdit.text()
        outputPath = self.ppToolsOPCFsOutputPathLineEdit.text()
        suffixOutputFiles = self.ppToolsOPCFsSuffixLineEdit.text()
        prefixOutputFiles = self.ppToolsOPCFsPrefixLineEdit.text()
        # ¿se puede ignorar para algunos procesos si hay varios ficheros de entrada? lasmerge ...
        # tengo que definir en un contenedor aquellos comandos que lo permiten
        if len(inputFiles ) > 1 and outputFile:
            if self.ppToolsOPCFsOutputPathPushButton.isEnabled():
                if not outputPath and not suffixOutputFiles:
                    msgBox = QMessageBox(self)
                    msgBox.setIcon(QMessageBox.Information)
                    msgBox.setWindowTitle(self.windowTitle)
                    msgBox.setText("Select output path or suffix for several input files")
                    msgBox.exec_()
                    return
        if not outputFile and not outputPath and not suffixOutputFiles:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select output file, output path or suffix")
            msgBox.exec_()
            return
        command = None
        if self.ppToolsTabWidget.currentIndex() == 0: # Lastools command
            if not self.lastoolsPath:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Select Lastools path")
                msgBox.exec_()
                return
            command = self.ppToolsLastoolsCommandComboBox.currentText()
            if command == PCTDefinitions.CONST_NO_COMBO_SELECT:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Select Lastools command")
                msgBox.exec_()
                return
        if not command:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Command is None")
            msgBox.exec_()
            return
        ret = self.iPyProject.pctGetLastoolsCommandStrings(command,
                                                           inputFiles,
                                                           outputPath,
                                                           outputFile,
                                                           suffixOutputFiles,
                                                           prefixOutputFiles)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        cont = 0
        for process in ret:
            if cont > 0:
                self.processList.append(ret[cont])
            cont = cont + 1
        # strValue = ""
        # cont = 0
        # for values in ret:
        #     if cont > 0:
        #         strValue += ret[cont]
        #         strValue += "\n"
        #     cont = cont + 1
        # dialog = TextEditDialog()
        # dialog.setValue(strValue)
        # dialog.exec_()
        # text = dialog.getValue()
        return

    def addPointCloudFiles(self):
        crs = self.addPCFsQgsProjectionSelectionWidget.crs()
        isValidCrs = crs.isValid()
        crsAuthId = crs.authid()
        if not "EPSG:" in crsAuthId:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not EPSG")
            msgBox.exec_()
            return
        crsEpsgCode = int(crsAuthId.replace('EPSG:',''))
        crsOsr = osr.SpatialReference()  # define test1
        if crsOsr.ImportFromEPSG(crsEpsgCode) != 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error importing OSR CRS from EPSG code" + str(crsEpsgCode))
            msgBox.exec_()
            return
        if not crsOsr.IsProjected():
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not a projected CRS")
            msgBox.exec_()
            return
        altitudeIsMsl = True
        if self.addPCFsAltitudeEllipsoidRadioButton.isChecked():
            altitudeIsMsl = False
        dbFileName = self.connections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        strPointCloudFiles = ''
        cont = 0
        for pointCloudFile in self.pointCloudFiles:
            if cont > 0:
                strPointCloudFiles = strPointCloudFiles + self.parametersFromPythonStringSeparator
            strPointCloudFiles = strPointCloudFiles + pointCloudFile
            cont = cont + 1
        ret = self.iPyProject.pctAddPointCloudFilesToProject(dbFileName,
                                                             crsEpsgCode,
                                                             altitudeIsMsl,
                                                             strPointCloudFiles)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
        else:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process completed successfully")
            msgBox.exec_()
        ret = self.iPyProject.pctGetMaximumDensity(dbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        self.maximumDensity = ret[1]
        if self.maximumDensity > 0:
            dblMinimumScale = 1000.0/sqrt(self.maximumDensity)*PCTDefinitions.CONST_POINTS_BY_MILIMETER
            for scale in self.scales:
                if scale < dblMinimumScale:
                    self.minimumScale = scale
                    if self.minimumScale < self.minimumValueForMinimumScale:
                        self.minimumScale = self.minimumValueForMinimumScale
                    break
        else:
            self.minimumScale = self.scales[0]
        tilesTableName = PCTDefinitions.CONST_SPATIALITE_LAYERS_TILES_TABLE_NAME
        self.loadTilesLayer()
        layerList = QgsProject.instance().mapLayersByName(tilesTableName)
        if not layerList:
            self.projectManagementTabWidget.setTabEnabled(2, False)
        else:
            tilesLayer = layerList[0]
            if tilesLayer.featureCount() > 0:
                self.projectManagementTabWidget.setTabEnabled(2, True)
                tilesLayer.triggerRepaint()
        return

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def closeProject(self):
        if not self.dbFileName:
            return
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)
        # delete project in ram??
        root = QgsProject.instance().layerTreeRoot()
        self.removeGroup(root,self.layerTreeProjectName)
        self.dbFileName = None
        self.layerTreeProjectName = None
        self.layerTreeProject = None
        self.layerTreePCTilesName = None
        self.layerTreePCTiles = None
        self.projectsComboBox.setEnabled(True)
        self.projectsComboBox.setCurrentIndex(0)
        self.iface.mapCanvas().refresh()
        self.manualEditingProcessesPage.setEnabled(False)
        self.storePointsData = True
        return

    def createProject(self):
        projectType = self.projectTypeComboBox.currentText()
        if projectType == PCTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project type")
            msgBox.exec_()
            return
        strGridSize = self.gridSizeComboBox.currentText()
        if strGridSize == PCTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project type")
            msgBox.exec_()
            return
        gridSize = Decimal(strGridSize)
        crs = self.projectQgsProjectionSelectionWidget.crs()
        isValidCrs = crs.isValid()
        crsAuthId = crs.authid()
        if not "EPSG:" in crsAuthId:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not EPSG")
            msgBox.exec_()
            return
        crsEpsgCode = int(crsAuthId.replace('EPSG:',''))
        crsOsr = osr.SpatialReference()  # define test1
        if crsOsr.ImportFromEPSG(crsEpsgCode) != 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error importing OSR CRS from EPSG code" + str(crsEpsgCode))
            msgBox.exec_()
            return
        if not crsOsr.IsProjected():
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not a projected CRS")
            msgBox.exec_()
            return
        altitudeIsMsl = True
        if self.projectAltitudeEllipsoidRadioButton.isChecked():
            altitudeIsMsl = False
        dbFileName = self.databaseLineEdit.text()
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        strRoisShapefiles = ''
        cont = 0
        for roiShapefile in self.roisShapefiles:
            if cont > 0:
                strRoisShapefiles = strRoisShapefiles + self.parametersFromPythonStringSeparator
            strRoisShapefiles = strRoisShapefiles + roiShapefile
            cont = cont + 1
        ret = self.iPyProject.pctCreateProject(dbFileName,
                                               projectType,
                                               strGridSize,  #gridSize,
                                               crsEpsgCode,
                                               altitudeIsMsl,
                                               strRoisShapefiles)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        connectionName = QFileInfo(dbFileName).fileName()
        con = [connectionName, dbFileName]
        QSettings().setValue("SpatiaLite/connections/%s/sqlitepath" % (con[0]), con[1])
        self.iface.reloadConnections()
        self.getSpatialiteConnections()
        msgBox = QMessageBox(self)
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(self.windowTitle)
        msgBox.setText("Process completed successfully")
        msgBox.exec_()
        return

    def initialize(self):
        self.dbFileName = None
        self.layerTreeName = None
        self.layerTree = None
        # self.path_plugin = os.path.dirname(os.path.realpath(__file__))
        # # pluginPath = 'python/plugins/point_cloud_tools'
        # # pluginPath = os.path.join(QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path(), pluginPath)
        # self.path_libCpp = os.path.join(self.pluginPath, 'libCpp')
        # existsPluginPath = QDir(self.path_libCpp).exists()
        # sys.path.append(self.path_plugin)
        # sys.path.append(self.path_libCpp)
        # os.environ["PATH"] += os.pathsep + self.path_libCpp
        # self.path_plugin = pluginPath
        # self.path_libCpp = libCppPath
        self.windowTitle = PCTDefinitions.CONST_PROGRAM_NAME
        # path_file_qsettings = self.path_plugin + '/' + PCTDefinitions.CONST_SETTINGS_FILE_NAME
        # self.settings = QSettings(path_file_qsettings,QSettings.IniFormat)

        qs = QSettings()

        # template path que cuelga del directorio de este fichero
        pluginsPath = QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path()
        thisFilePath = os.path.dirname(os.path.realpath(__file__))
        thisFilePath = os.path.join(pluginsPath, thisFilePath)
        # templatePath = os.path.join(thisFilePath, PCTDefinitions.CONST_TEMPLATE_PATH)
        self.templatePath = thisFilePath + PCTDefinitions.CONST_TEMPLATE_PATH
        svg_paths = qs.value('svg/searchPathsForSVG')
        # if self.templatePath not in svg_paths:
            # qs.setValue('svg/searchPathsForSVG', svg_paths + [self.templatePath])
        qs.setValue('svg/searchPathsForSVG', self.templatePath)
        # if not svg_paths:
            # qs.setValue('svg/searchPathsForSVG', self.templatePath)
        # else:
            # qs.setValue('svg/searchPathsForSVG', svg_paths + [self.templatePath])

        self.qmlPointCloudFileName = self.templatePath + PCTDefinitions.CONST_SYMBOLOGY_POINT_CLOUD_TEMPLATE
        self.qmlTilesFileName = self.templatePath + PCTDefinitions.CONST_SYMBOLOGY_TILES_TEMPLATE
        self.qmlRoisFileName = self.templatePath + PCTDefinitions.CONST_SYMBOLOGY_ROIS_TEMPLATE
        self.path = self.settings.value("last_path")
        if not self.path:
            self.path = QDir.currentPath()
            self.settings.setValue("last_path",self.path)
            self.settings.sync()

        self.projectManagerTemporalPath = self.settings.value("project_management_temporal_path")
        auxDir = QDir(self.path)
        if not self.projectManagerTemporalPath or not auxDir.exists(self.projectManagerTemporalPath):
            self.projectManagerTemporalPath = self.path_libCpp + PCTDefinitions.CONST_PROJECT_MANAGEMENT_TEMPORAL_PATH
            self.settings.setValue("project_management_temporal_path", self.projectManagerTemporalPath)
            self.settings.sync()
        self.pmTemporalPathLineEdit.setText(self.projectManagerTemporalPath)

        self.projectManagerOutputPath = self.settings.value("project_management_output_path")
        auxDir = QDir(self.path)
        if not self.projectManagerOutputPath or not auxDir.exists(self.projectManagerOutputPath):
            self.projectManagerOutputPath = self.path_libCpp + PCTDefinitions.CONST_PROJECT_MANAGEMENT_OUTPUT_PATH
            self.settings.setValue("project_management_output_path", self.projectManagerOutputPath)
            self.settings.sync()
        self.pmOutputPathLineEdit.setText(self.projectManagerOutputPath)

        self.lastoolsPath = self.settings.value("lastools_path")
        if self.lastoolsPath:
            if not auxDir.exists(self.lastoolsPath):
                self.lastoolsPath = None
            if self.lastoolsPath:
                self.ppToolsLastoolsPathLineEdit.setText(self.lastoolsPath)
        self.roisShapefiles = []
        self.roisFileTypes = []
        self.processList = []
        self.roisFileTypes.append(PCTDefinitions.CONST_DOCUMENTS_TYPE_SHAPEFILE)
        self.roisFilesActiveFileExtensions = self.roisFileTypes
        self.pointCloudFiles = []
        self.postprocessingIPCFs = []
        self.pointCloudFilesFileTypes = []
        self.storePointsData = True
        self.maximumDensity = 0.0
        self.minimumScale = 1000
        self.minimumValueForMinimumScale = 50
        self.scales = [10000,5000,2000,1000,500,200,100,50,10,1]
        self.pointCloudFilesFileTypes.append(PCTDefinitions.CONST_DOCUMENTS_TYPE_LASFILE)
        self.pointCloudFilesFileTypes.append(PCTDefinitions.CONST_DOCUMENTS_TYPE_LAZFILE)
        self.pointCloudFilesActiveFileExtensions = self.pointCloudFilesFileTypes

        spatialiteConnections = qs.value("SpatiaLite/connections")
        # self.iPyProject=IPyPCTProject()
        self.parametersFromPythonStringSeparator = self.iPyProject.getParametersFromPythonStringSeparator()
        # kk_str = self.iPyProject.output()
        # kk_list =  self.iPyProject.getVd()
        # kk_dict =  self.iPyProject.getMapSS()
        # self.iPyProject.setPythonModulePath(libCppPath)
        # ret = self.iPyProject.initialize()
        if self.isPCTPlugin:
            ret = self.iPyProject.setPointCloudDbManager()
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n"+ret[1])
                msgBox.exec_()
                return
        if self.lastoolsPath:
            ret = self.iPyProject.pctSetLastoolsPath(self.lastoolsPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.ppToolsLastoolsPathLineEdit.setText("")
                self.lastoolsPath = None
                return
        ret = self.iPyProject.pctSetProjectManagerTemporalPath(self.projectManagerTemporalPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmTemporalPathLineEdit.setText("")
            self.projectManagerTemporalPath = None
            return
        ret = self.iPyProject.pctSetProjectManagerOutputPath(self.projectManagerOutputPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmOutputPathLineEdit.setText("")
            self.projectManagerOutputPath = None
            return

        self.layerTreeProject = None
        self.layerTreeProjectName = None
        self.layerTreePCTiles = None
        self.layerTreePCTilesName = None
        self.loadedTiles = []

        # set projectManagement active
        self.toolBox.setCurrentIndex(0)

        ###################################################
        # Preprocessing tools
        ###################################################

        self.lastoolsCommands = self.iPyProject.pctGetLastoolsCommands()
        self.ppToolsLastoolsCommandComboBox.addItem(PCTDefinitions.CONST_NO_COMBO_SELECT)
        for lastoolsCommand in self.lastoolsCommands:
            self.ppToolsLastoolsCommandComboBox.addItem(lastoolsCommand)
        self.ppToolsLastoolsCommandComboBox.currentIndexChanged.connect(self.selectLastoolsCommand)
        self.selectLastoolsCommand()
        self.ppToolsLastoolsCommandParametersPushButton.setEnabled(False)

        # Parameters
        self.ppToolsLastoolsCommandParametersPushButton.clicked.connect(self.selectLastoolsCommandParameters)

        self.addProcessToListPushButton.clicked.connect(self.addProcessToList)
        self.processListEditionPushButton.clicked.connect(self.processListEdition)
        self.runProcessListPushButton.clicked.connect(self.runProcessList)

        self.ppToolsSelectIPCFsPushButton.clicked.connect(self.selectPostprocessingIPCFs)
        self.ppToolsLastoolsPathPushButton.clicked.connect(self.selectLastoolsPath)
        self.ppToolsOPCFsOutputFilePushButton.clicked.connect(self.selectPpToolsOutputFile)
        self.ppToolsOPCFsOutputPathPushButton.clicked.connect(self.selectPpToolsOutputPath)
        self.ppToolsOPCFsSuffixPushButton.clicked.connect(self.selectPpToolsOutpufFilesSuffix)
        self.ppToolsOPCFsPrefixPushButton.clicked.connect(self.selectPpToolsOutpufFilesPrefix)


        ###################################################
        # Project Management Page
        ###################################################
        # Projects spatialite databases
        self.getSpatialiteConnections()
        if self.isPCTPlugin:
            self.projectsComboBox.currentIndexChanged.connect(self.selectProject)

        # Project
        self.openProjectPushButton.clicked.connect(self.openProject)
        self.closeProjectPushButton.clicked.connect(self.closeProject)

        # Project types
        self.projecTypes = self.iPyProject.pctGetProjectTypes()
        self.projectTypeComboBox.addItem(PCTDefinitions.CONST_NO_COMBO_SELECT)
        for projectType in self.projecTypes:
            self.projectTypeComboBox.addItem(projectType)
        self.projectTypeComboBox.currentIndexChanged.connect(self.selectProjectType)

        # Grid sizes
        gridSizes = self.iPyProject.pctGetGridSizes()
        self.gridSizeComboBox.addItem(PCTDefinitions.CONST_NO_COMBO_SELECT)
        for gridSize in gridSizes:
            strGridSize = str(round(gridSize, PCTDefinitions.CONST_GRID_SIZE_ACCURACY))
            self.gridSizeComboBox.addItem(strGridSize)

        # Parameters
        self.projectParametersPushButton.clicked.connect(self.selectProjectParameters)

        # DbFile
        self.databasePushButton.clicked.connect(self.selectNewDatabase)

        self.projectManagementTabWidget.setTabEnabled(0,True)
        self.projectManagementTabWidget.setTabEnabled(1,False)
        self.projectManagementTabWidget.setCurrentIndex(0)
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)

        # ROIs
        self.roisPushButton.clicked.connect(self.selectRois)
        self.numberOfRoisLineEdit.setText("0")

        # PCFs
        self.selectPCFsPushButton.clicked.connect(self.selectPCFs)
        self.numberOfPCFsLineEdit.setText("0")
        self.addPCFsProcessPushButton.clicked.connect(self.addPointCloudFiles)

        # create
        self.createProjectPushButton.clicked.connect(self.createProject)

        # export
        self.exportPPCFsOutputPathPushButton.clicked.connect(self.exportPPCFsOutputPath)
        self.exportPPCFsSuffixPushButton.clicked.connect(self.exportPPCFsSuffix)
        self.exportPPCFsProcessPushButton.clicked.connect(self.exportPPCFsProcess)

        # reclassification confusion matrix report
        self.reclassificationConfusionMatrixReportSelectClassesPushButton.clicked.connect(self.selectReclassificationConfusionMatrixSelectClasses)
        self.reclassificationConfusionMatrixReportOutputFilePushButton.clicked.connect(self.selectReclassificationConfusionMatrixReportFile)
        self.reclassificationConfussionMatrixReportSelectedClassesRadioButton.clicked.connect(self.selectReclassificationConfusionMatrixSelectedClasses)
        self.reclassificationConfusionMatrixReportAllClassesRadioButton.clicked.connect(self.selectReclassificationConfusionMatrixReportAllClasses)
        # strReclassificationConfusionMatrixReportSelectedClasses=definitions.CONST_RCM_REPORT_DEFAULT_SELECTED_CLASSES
        strReclassificationConfusionMatrixReportSelectedClasses="2;3;4;5;6;7"
        self.reclassificationConfusionMatrixReportSelectClassesLineEdit.setText(strReclassificationConfusionMatrixReportSelectedClasses)
        self.reclassificationConfusionMatrixReportSelectClassesLineEdit.setEnabled(True)
        self.reclassificationConfussionMatrixReportSelectedClassesRadioButton.setChecked(True)
        self.reclassificationConfusionMatrixReportSelectClassesPushButton.setEnabled(True)
        self.reclassificationConfusionMatrixReportValidSelectClasses = [0,1,2,3,4,5,6,7,8,9,12]
        self.reclassificationConfusionMatrixReportProcessPushButton.clicked.connect(self.selectReclassificationConfusionMatrixReportProcess)

        # temporal path
        self.pmTemporalPathPushButton.clicked.connect(self.selectProjectManagerTemporalPath)
        self.pmOutputPathPushButton.clicked.connect(self.selectProjectManagerOutputPath)

        ###################################################
        # Manual Editing Processes Page
        ###################################################
        self.manualEditingProcessesPage.setEnabled(False)
        self.loadTilesMapCanvasPushButton.clicked.connect(self.selectLoadTilesForMapCanvas)
        self.unloadAllTilesPushButton.clicked.connect(self.unloadAllTiles)
        self.toolButton_SelectByRectangle.clicked.connect(self.selectPointFromTilesByRectangle)
        self.toolButton_SelectByPolygon.clicked.connect(self.selectPointsFromTilesByPolygon)
        self.toolButton_SelectByFreehand.clicked.connect(self.selectPointsFromTilesByFreehand)
        self.toolButton_SelectByRectangle_3D.clicked.connect(self.selectPointFromTilesByRectangle3D)
        self.toolButton_SelectByPolygon_3D.clicked.connect(self.selectPointsFromTilesByPolygon3D)
        self.toolButton_SelectByFreehand_3D.clicked.connect(self.selectPointsFromTilesByFreehand3D)
        self.view3dMapCanvasPushButton.clicked.connect(self.view3dMapCanvas)
        self.lockedClasses={0:False,1:False,2:False,3:False,4:False,5:False,6:False,7:False,8:False,9:False,10:False,11:False,12:False,13:False}
        self.lavelSimbolByClassNumber={0:"Created",1:"Unclassified",2:"Ground",3:"Low Vegetation",4:"Medium Vegetation",
                                5:"High Vegetation",6:"Building",7:"Low Point (noise)",8:"Model Key-point (mass point)",
                                       9:"Water",12:"Overlap Points"}
        self.visibleCheckBoxByClassNumber={0: self.visibleClass0CheckBox,
                                           1: self.visibleClass1CheckBox,
                                           2: self.visibleClass2CheckBox,
                                           3: self.visibleClass3CheckBox,
                                           4: self.visibleClass4CheckBox,
                                           5: self.visibleClass5CheckBox,
                                           6: self.visibleClass6CheckBox,
                                           7: self.visibleClass7CheckBox,
                                           # 8: self.visibleClass8CheckBox,
                                           9: self.visibleClass9CheckBox,
                                           12: self.visibleClass12CheckBox}
        self.toClass0PushButton.clicked.connect(self.toClass0)
        self.toClass1PushButton.clicked.connect(self.toClass1)
        self.toClass12PushButton.clicked.connect(self.toClass12)
        self.toClass2PushButton.clicked.connect(self.toClass2)
        self.toClass3PushButton.clicked.connect(self.toClass3)
        self.toClass4PushButton.clicked.connect(self.toClass4)
        self.toClass5PushButton.clicked.connect(self.toClass5)
        self.toClass6PushButton.clicked.connect(self.toClass6)
        self.toClass7PushButton.clicked.connect(self.toClass7)
        self.toClass9PushButton.clicked.connect(self.toClass9)
        self.getAltitudeStatisticsForSelectedPointsPushButton.clicked.connect(self.selectGetAltitudeStatisticsForSelectedPoints)
        self.getDifferencesAltitudeForSelectedPointsPushButton.clicked.connect(self.selectGetDifferencesAltitudeForSelectedPoints)
        self.removeRadioButton.clicked.connect(self.enableAllClasses)
        self.recoverRadioButton.clicked.connect(self.enableAllClasses)
        self.changeClassRadioButton.clicked.connect(self.unenableAllClasses)
        self.selectOnlyRadioButton.clicked.connect(self.unenableAllClasses)
        self.unselectRadioButton.clicked.connect(self.unenableAllClasses)
        self.toOriginalClassRadioButton.clicked.connect(self.toOriginalClass)
        self.allClassesPushButton.clicked.connect(self.selectAllClasses)
        self.getDifferencesAltitudeForSelectedPointsPushButton.setEnabled(False)
        self.visibleClass0CheckBox.setChecked(True)
        self.visibleClass1CheckBox.setChecked(True)
        self.visibleClass2CheckBox.setChecked(True)
        self.visibleClass3CheckBox.setChecked(True)
        self.visibleClass4CheckBox.setChecked(True)
        self.visibleClass5CheckBox.setChecked(True)
        self.visibleClass6CheckBox.setChecked(True)
        self.visibleClass7CheckBox.setChecked(True)
        self.visibleClass9CheckBox.setChecked(True)
        self.visibleClass12CheckBox.setChecked(True)
        self.visibleClass0CheckBox.clicked.connect(self.actionSetVisiblePoints)
        self.visibleClass1CheckBox.clicked.connect(self.actionSetVisiblePoints)
        self.visibleClass2CheckBox.clicked.connect(self.actionSetVisiblePoints)
        self.visibleClass3CheckBox.clicked.connect(self.actionSetVisiblePoints)
        self.visibleClass4CheckBox.clicked.connect(self.actionSetVisiblePoints)
        self.visibleClass5CheckBox.clicked.connect(self.actionSetVisiblePoints)
        self.visibleClass6CheckBox.clicked.connect(self.actionSetVisiblePoints)
        self.visibleClass7CheckBox.clicked.connect(self.actionSetVisiblePoints)
        self.visibleClass9CheckBox.clicked.connect(self.actionSetVisiblePoints)
        self.visibleClass12CheckBox.clicked.connect(self.actionSetVisiblePoints)


        if not self.isPCTPlugin:
            self.projectsComboBox.setEnabled(False)
        self.selectProject()

        # self.processingToolsPage.setEnabled(False)

    def enableAllClasses(self):
        self.allClassesPushButton.setEnabled(True)
        return

    def exportPPCFsOutputPath(self):
        strDir = QFileDialog.getExistingDirectory(self,"Select directory",self.path,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            self.path = strDir
            self.settings.setValue("last_path", self.path)
            self.settings.sync()
            self.exportPPCFsOutputPathLineEdit.setText(strDir)
        return

    def exportPPCFsSuffix(self):
        oldText = self.exportPPCFsSuffixLineEdit.text()
        label = "Input suffix for exported point cloud files:"
        title = PCTDefinitions.CONST_PROGRAM_TITLE
        [text, ok] = QInputDialog.getText(self, title, label, QLineEdit.Normal, oldText)
        if ok and text:
            text = text.strip()
            if not text == oldText:
                self.exportPPCFsSuffixLineEdit.setText(text)
        return

    def exportPPCFsProcess(self):
        outputPath = self.exportPPCFsOutputPathLineEdit.text()
        suffix = self.exportPPCFsSuffixLineEdit.text()
        if not outputPath and not suffix:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("You must select an output folder or a suffix for export processeed point cloud files")
            msgBox.exec_()
            return
        ret = self.iPyProject.pctExportProcessedPointCloudFiles(self.dbFileName,
                                                                suffix,
                                                                outputPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        else:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process completed successfully")
            msgBox.exec_()
        return

    def getSelectedPointsIdByTableName(self):
        selectedPointsIdByTableName = {}
        numberOfSelectedPoints = 0
        for loadTile in self.loadedTiles:
            layers = QgsProject.instance().mapLayersByName(loadTile)
            if len(layers) == 1:
                layer = layers[0]
                if layer.type() == QgsMapLayer.VectorLayer:
                    features = layer.selectedFeatures()
                    selectedPointsId = []
                    for feature in features:
                        pointId = feature[PCTDefinitions.CONST_LAYER_PCTILES_FIELD_ID_NAME]
                        selectedPointsId.append(pointId)
                        numberOfSelectedPoints = numberOfSelectedPoints + 1
                    if len(selectedPointsId) > 0:
                        selectedPointsIdByTableName[loadTile] = selectedPointsId
        return [selectedPointsIdByTableName,numberOfSelectedPoints]

    def getSpatialiteConnections(self):
        self.connections = {}
        settings = QSettings()
        settings.beginGroup('/SpatiaLite/connections')
        list_str_keys = settings.allKeys()
        paths = []
        for key in list_str_keys:
            if key!= 'selected':
                paths.append(settings.value(key))
        ret = self.iPyProject.getPointCloudSpatialiteDbs(paths)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmTemporalPathLineEdit.setText("")
            self.projectManagerTemporalPath = None
            return
        connectionNames = settings.childGroups()
        cont = 0
        for connectionName in connectionNames:
            path = paths[cont]
            if path in ret:
                self.connections[connectionName] = paths[cont]
            cont = cont + 1
        self.projectsComboBox.clear()
        self.projectsComboBox.addItem(PCTDefinitions.CONST_NO_COMBO_SELECT)
        for connection in self.connections.keys():
            self.projectsComboBox.addItem(connection)
        return

    def loadROIsLayer(self):
        roisTableName = PCTDefinitions.CONST_SPATIALITE_LAYERS_ROIS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(roisTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = roisTableName
            geom_column = PCTDefinitions.CONST_SPATIALITE_LAYERS_ROIS_TABLE_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = roisTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer,False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlRoisFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
            else:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Impossible to Load table: " + roisTableName
                                   +" into QGIS")
                msgBox.exec_()

    def loadTilesLayer(self):
        tilesTableName = PCTDefinitions.CONST_SPATIALITE_LAYERS_TILES_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(tilesTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = tilesTableName
            geom_column = PCTDefinitions.CONST_SPATIALITE_LAYERS_TILES_TABLE_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = tilesTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer,False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlTilesFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
            else:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Impossible to Load table: " + tilesTableName
                                   +" into QGIS")
                msgBox.exec_()
        else:
            vlayer = layerList[0]
            vlayer.triggerRepaint()

    def openProject(self):
        self.manualEditingProcessesPage.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)
        self.dbFileName = None
        self.layerTreeName = None
        self.layerTree = None
        connectionFileName = self.projectsComboBox.currentText()
        if connectionFileName == PCTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project before")
            msgBox.exec_()
            return
        connectionPath = self.connections[connectionFileName]
        ret = self.iPyProject.pctOpenProject(connectionPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        ret = self.iPyProject.pctGetStorePointsData(connectionPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        self.storePointsData = True
        if ret[1] == "False":
            self.storePointsData = False
        ret = self.iPyProject.pctGetMaximumDensity(connectionPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        self.maximumDensity = ret[1]
        if self.maximumDensity > 0:
            dblMinimumScale = 1000.0/sqrt(self.maximumDensity)*PCTDefinitions.CONST_POINTS_BY_MILIMETER
            for scale in self.scales:
                if scale < dblMinimumScale:
                    self.minimumScale = scale
                    if self.minimumScale < self.minimumValueForMinimumScale:
                        self.minimumScale = self.minimumValueForMinimumScale
                    break
        else:
            self.minimumScale = self.scales[0]
        self.dbFileName = connectionPath
        groupName = PCTDefinitions.CONST_LAYER_TREE_PROJECT_NAME
        self.layerTreeProjectName = groupName + connectionFileName
        root = QgsProject.instance().layerTreeRoot()
        self.layerTreeProject = root.addGroup(self.layerTreeProjectName)
        self.loadROIsLayer()
        self.loadTilesLayer()
        self.closeProjectPushButton.setEnabled(True)
        self.openProjectPushButton.setEnabled(False)
        self.projectsComboBox.setEnabled(False)
        self.projectManagementTabWidget.setEnabled(True)
        self.projectManagementTabWidget.setTabEnabled(0, False)
        self.projectManagementTabWidget.setTabEnabled(1, True)
        tilesTableName = PCTDefinitions.CONST_SPATIALITE_LAYERS_TILES_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(tilesTableName)
        if not layerList:
            self.projectManagementTabWidget.setTabEnabled(2, False)
        else:
            tilesLayer = layerList[0]
            if tilesLayer.featureCount() > 0:
                self.projectManagementTabWidget.setTabEnabled(2, True)
        self.manualEditingProcessesPage.setEnabled(True)
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Process completed successfully")
        # msgBox.exec_()
        return

    def processListEdition(self):
        previousProcessList = self.processList[:] # copia desligada
        dlg = ProcessListEditonDialog(PCTDefinitions.CONST_PROCESS_LIST_EDITION_DIALOG_TITLE,
                                      self.processList)
        dlg.show() # show the dialog
        result = dlg.exec_() # Run the dialog
        processList = dlg.getProcessList() # los hay repetidos
        self.processList = []
        for process in processList:
            self.processList.append(process)
        return

    def removeGroup(self,root,name):
        # root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(name)
        if not group is None:
            for child in group.children():
                dump = child.dump()
                id = dump.split("=")[-1].strip()
                QgsProject.instance().removeMapLayer(id)
            root.removeChildNode(group)

    def selectGetAltitudeStatisticsForSelectedPoints(self):
        self.meanAltitudeLineEdit.clear()
        self.stdAltitudeLineEdit.clear()
        self.altitudeDifferenceLineEdit.clear()
        self.getDifferencesAltitudeForSelectedPointsPushButton.setEnabled(False)
        [selectedPointsIdByTableName,numberOfSelectedPoints] = self.getSelectedPointsIdByTableName()
        if numberOfSelectedPoints == 0:
            return
        ret = self.iPyProject.pctGetAltitudeStatisticsForSelectedPoints(self.dbFileName,
                                                                        selectedPointsIdByTableName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        meanAltitude = ret[1]
        stdAltitude = ret[2]
        self.meanAltitudeLineEdit.setText("{:.3f}".format(meanAltitude))
        self.stdAltitudeLineEdit.setText("{:.3f}".format(stdAltitude))
        self.getDifferencesAltitudeForSelectedPointsPushButton.setEnabled(True)
        return

    def selectPointFromTilesByRectangle(self):
        # self.toolRectangle = RectangleMapTool(self.iface.mapCanvas())
        self.toolRectangle = RectangleMapTool(self.iface.mapCanvas(),
                                              self.loadedTiles)
        self.iface.mapCanvas().setMapTool(self.toolRectangle)
        # self.iface.mapCanvas().unsetMapTool(self.toolRectangle)

    def selectPointFromTilesByRectangle3D(self):
        # self.toolRectangle = RectangleMapTool(self.iface.mapCanvas())
        selectPoints = False
        self.toolRectangle3D = None
        self.toolPolygon3D = None
        self.toolFreehand3D = None
        self.toolRectangle3D = RectangleMapTool(self.iface.mapCanvas(),
                                              self.loadedTiles,
                                              selectPoints)
        self.toolRectangle3D.endSelection.connect(self.view3DSelectedPoints)
        self.iface.mapCanvas().setMapTool(self.toolRectangle3D)
        # self.iface.mapCanvas().unsetMapTool(self.toolRectangle)

    def selectedPointsIdByTableName(self,selectedPointsIdByTableName):
        field_name = PCTDefinitions.CONST_LAYER_PCTILES_FIELD_ID_NAME
        for loadTile in selectedPointsIdByTableName:
            layers = QgsProject.instance().mapLayersByName(loadTile)
            if len(layers) == 1:
                layer = layers[0]
                if layer.type() == QgsMapLayer.VectorLayer:
                    layer.removeSelection()
                    selectedIdsFeatures = []
                    for pointId in selectedPointsIdByTableName[loadTile]:
                        expr = QgsExpression(field_name + ' = ' + str(pointId))
                        selection = layer.getFeatures(QgsFeatureRequest(expr))
                        for s in selection:
                            # layer.select(s.id())
                            selectedIdsFeatures.append(s.id())
                    # layer.setSelectedFeatures(selectedIdsFeatures)
                    layer.selectByIds(selectedIdsFeatures)
        return

    def selectPointsFromTilesByFreehand(self):
        self.toolFreehand= FreehandMapTool(self.iface.mapCanvas(),
                                              self.loadedTiles)
        self.iface.mapCanvas().setMapTool(self.toolFreehand)
        # self.iface.mapCanvas().unsetMapTool(self.toolPolygon)

    def selectPointsFromTilesByFreehand3D(self):
        # self.toolRectangle = RectangleMapTool(self.iface.mapCanvas())
        selectPoints = False
        self.toolRectangle3D = None
        self.toolPolygon3D = None
        self.toolFreehand3D = None
        self.toolFreehand3D = FreehandMapTool(self.iface.mapCanvas(),
                                              self.loadedTiles,
                                              selectPoints)
        self.toolFreehand3D.endSelection.connect(self.view3DSelectedPoints)
        self.iface.mapCanvas().setMapTool(self.toolFreehand3D)
        # self.iface.mapCanvas().unsetMapTool(self.toolRectangle)

    def selectPointsFromTilesByPolygon(self):
        self.toolPolygon= PolygonMapTool(self.iface.mapCanvas(),
                                              self.loadedTiles)
        self.iface.mapCanvas().setMapTool(self.toolPolygon)
        # self.iface.mapCanvas().unsetMapTool(self.toolPolygon)

    def selectPointsFromTilesByPolygon3D(self):
        # self.toolRectangle = RectangleMapTool(self.iface.mapCanvas())
        selectPoints = False
        self.toolRectangle3D = None
        self.toolPolygon3D = None
        self.toolFreehand3D = None
        self.toolPolygon3D = PolygonMapTool(self.iface.mapCanvas(),
                                              self.loadedTiles,
                                              selectPoints)
        self.toolPolygon3D.endSelection.connect(self.view3DSelectedPoints)
        self.iface.mapCanvas().setMapTool(self.toolPolygon3D)
        # self.iface.mapCanvas().unsetMapTool(self.toolRectangle)

    def selectGetDifferencesAltitudeForSelectedPoints(self):
        self.altitudeDifferenceLineEdit.clear()
        [selectedPointsIdByTableName,numberOfSelectedPoints] = self.getSelectedPointsIdByTableName()
        if numberOfSelectedPoints == 0:
            return
        if numberOfSelectedPoints > 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select a single point")
            msgBox.exec_()
            # self.projectsComboBox.setCurrentIndex(0)
            return
        ret = self.iPyProject.pctGetAltitudeStatisticsForSelectedPoints(self.dbFileName,
                                                                        selectedPointsIdByTableName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            # self.projectsComboBox.setCurrentIndex(0)
            return
        altitude = ret[1]
        stdAltitude = ret[2]
        strMeanAltitude = self.meanAltitudeLineEdit.text()
        meanAltitude = float(strMeanAltitude)
        altitude_diff = altitude - meanAltitude
        self.altitudeDifferenceLineEdit.setText("{:.3f}".format(altitude_diff))
        return

    def selectLastoolsCommand(self):
        self.ppToolsOPCFsOutputFilePushButton.setEnabled(False)
        self.ppToolsOPCFsOutputFileLineEdit.setText("")
        self.ppToolsOPCFsOutputPathPushButton.setEnabled(False)
        self.ppToolsOPCFsOutputPathLineEdit.setText("")
        self.ppToolsOPCFsSuffixPushButton.setEnabled(False)
        self.ppToolsOPCFsSuffixLineEdit.setText("")
        self.ppToolsOPCFsPrefixPushButton.setEnabled(False)
        self.ppToolsOPCFsPrefixLineEdit.setText("")
        lastoolsCommand = self.ppToolsLastoolsCommandComboBox.currentText()
        if lastoolsCommand == PCTDefinitions.CONST_NO_COMBO_SELECT:
            self.ppToolsLastoolsCommandParametersPushButton.setEnabled(False)
            return
        ret = self.iPyProject.pctGetLastoolsCommandsOutputDataFormat(lastoolsCommand)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        if ret[1] == "True":
            self.ppToolsOPCFsOutputPathPushButton.setEnabled(True)
        if ret[2] == "True":
            self.ppToolsOPCFsOutputFilePushButton.setEnabled(True)
        if ret[3] == "True":
            self.ppToolsOPCFsSuffixPushButton.setEnabled(True)
        if ret[4] == "True":
            self.ppToolsOPCFsPrefixPushButton.setEnabled(True)
        self.ppToolsLastoolsCommandParametersPushButton.setEnabled(True)
        return

    def selectLastoolsCommandParameters(self):
        lastoolsCommand = self.ppToolsLastoolsCommandComboBox.currentText()
        if lastoolsCommand == PCTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select lastools command before")
            msgBox.exec_()
            return
        ret = self.iPyProject.pctSelectLastoolsCommandParameters(lastoolsCommand)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
        return

    def selectLastoolsPath(self):
        strDir = QFileDialog.getExistingDirectory(self,"Select directory",self.path,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            ret = self.iPyProject.pctSetLastoolsPath(strDir)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.ppToolsLastoolsPathLineEdit.setText("")
                self.lastoolsPath = None
                return
            self.lastoolsPath = strDir
            self.settings.setValue("lastools_path", self.lastoolsPath)
            self.settings.sync()
            self.ppToolsLastoolsPathLineEdit.setText(strDir)
        return

    def selectLoadTilesForMapCanvas(self):
        mapCanvasExtend = self.iface.mapCanvas().extent()
        maxFc = mapCanvasExtend.xMaximum()
        maxSc = mapCanvasExtend.yMaximum()
        minFc = mapCanvasExtend.xMinimum()
        minSc = mapCanvasExtend.yMinimum()
        mapCanvasWkt = 'POLYGON((' + str(minFc)+ ' '+str(maxSc) + ',' \
                        + str(maxFc) + ' ' + str(maxSc) + ',' \
                        + str(maxFc) + ' ' + str(minSc) + ',' \
                        + str(minFc) + ' ' + str(minSc) + ',' \
                        + str(minFc) + ' ' + str(maxSc) + '))'
        # mapCanvasGeometry = ogr.CreateGeometryFromWkt(mapCanvasWkt)
        # epsgCode = int(self.lidarFilesCrs.authid().replace("EPSG:",""))
        projectCrs = QgsProject.instance().crs()
        projectCrsEpsgCode = -1
        projectCrsProj4 = ""
        projectCrsAuthId = projectCrs.authid()
        if "EPSG" in projectCrsAuthId:
            projectCrsEpsgCode = int(projectCrsAuthId.replace("EPSG:",""))
        projectCrsProj4 = projectCrs.toProj4()
        # mapCanvasCrsEpsgCode = int(self.iface.mapCanvas().mapRenderer().destinationCrs().authid().replace("EPSG:",""))
        # mapCanvasCrs = self.iface.mapCanvas().mapRenderer().destinationCrs()
        if self.storePointsData:
            ret = self.iPyProject.pctGetTilesTableNamesFromWktGeometry(self.dbFileName,
                                                                       mapCanvasWkt,
                                                                       projectCrsEpsgCode,
                                                                       projectCrsProj4)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n"+ret[1])
                msgBox.exec_()
                return
            if not self.layerTreePCTiles:
                self.layerTreePCTilesName = PCTDefinitions.CONST_LAYER_TREE_PCTILES_NAME
                self.layerTreePCTiles = self.layerTreeProject.addGroup(self.layerTreePCTilesName)
            cont = 0
            for value in ret:
                if cont > 0:
                    tileTableName = value
                    if tileTableName in self.loadedTiles:
                        continue
                    layerList = QgsProject.instance().mapLayersByName(tileTableName)
                    if layerList:
                        continue
                    uri = QgsDataSourceUri()
                    uri.setDatabase(self.dbFileName)
                    schema = ''
                    table = tileTableName
                    geom_column = PCTDefinitions.CONST_SPATIALITE_LAYERS_TILE_TABLE_GEOMETRY_COLUMN
                    uri.setDataSource(schema, table, geom_column)
                    display_name = tileTableName
                    vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
                    if vlayer.isValid():
                        # if vlayer.featureCount() == 0:
                        #     return
                        QgsProject.instance().addMapLayer(vlayer, False)
                        self.layerTreePCTiles.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                        vlayer.loadNamedStyle(self.qmlPointCloudFileName)
                        vlayer.triggerRepaint()
                        # self.iface.setActiveLayer(vlayer)
                        # self.iface.zoomToActiveLayer()
                        self.loadedTiles.append(tileTableName)
                    else:
                        msgBox = QMessageBox(self)
                        msgBox.setIcon(QMessageBox.Information)
                        msgBox.setWindowTitle(self.windowTitle)
                        msgBox.setText("Impossible to Load table: " + tileTableName
                                           + " into QGIS")
                        msgBox.exec_()
                cont = cont + 1
        else:
            ret = self.iPyProject.pctGetTilesFromWktGeometry(self.dbFileName,
                                                             mapCanvasWkt,
                                                             projectCrsEpsgCode,
                                                             projectCrsProj4,
                                                             self.loadedTiles)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n"+ret[1])
                msgBox.exec_()
                return
            if not self.layerTreePCTiles:
                self.layerTreePCTilesName = PCTDefinitions.CONST_LAYER_TREE_PCTILES_NAME
                self.layerTreePCTiles = self.layerTreeProject.addGroup(self.layerTreePCTilesName)

            tilesTableNamesById = ret[1]# QMap < int, QString > tilesTableNamesById;
            pointsTilesTableNameId = ret[2]# QVector < int > pointsTilesTableNameId;
            pointsIdInTileTable = ret[3]# QVector < int > pointsIdInTileTable;
            # pointsGpsTime = ret[4]# QVector < double > pointsGpsTime;
            # pointsBlue = ret[5]# QVector < int > pointsBlue;
            # pointsRed = ret[6]# QVector < int > pointsRed;
            # pointsGreen = ret[7]# QVector < int > pointsGreen;
            # pointsNir = ret[8]# QVector < int > pointsNir;
            # pointsIntensity = ret[9]# QVector < int > pointsIntensity;
            # pointsReturns = ret[10]# QVector < int > pointsReturns;
            # pointsReturn = ret[11]# QVector < int > pointsReturn;
            pointsClass = ret[12]# QVector < int > pointsClass;
            pointsClassNew = ret[13]# QVector < int > pointsClassNew;
            pointsRemoved = ret[14]# QVector < bool > pointsRemoved;
            pointsFc = ret[15]# QVector < double > pointsFc;
            pointsSc = ret[16]# QVector < double > pointsSc;
            # pointsHeight = ret[17]# QVector < double > pointsHeight;
            pointsAltitude = ret[18]# QVector < double > pointsAltitude;
            featuresByTileTableName = {}
            for tileTableNameId in tilesTableNamesById:
                tileTableName = tilesTableNamesById[tileTableNameId]
                # if tileTableName in self.loadedTiles:
                #     continue
                layerList = QgsProject.instance().mapLayersByName(tileTableName)
                if layerList:
                    continue
                layerParameters = "Point?crs=EPSG:" + str(projectCrsEpsgCode)
                layerParameters += "&field=id:integer"
                layerParameters += "&field=class_new:integer(2)"
                layerParameters += "&field=class:integer(2)"
                layerParameters += "&field=altitude:double"
                layerParameters += "&field=removed:integer(1)"
                vlayer = QgsVectorLayer(layerParameters,tileTableName, "memory")
                if vlayer.isValid():
                    # if vlayer.featureCount() == 0:
                    #     return
                    featuresByTileTableName[tileTableName] = []
                    QgsProject.instance().addMapLayer(vlayer, False)
                    self.layerTreePCTiles.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                    # vlayer.loadNamedStyle(self.qmlPointCloudFileName)
                    # vlayer.triggerRepaint()
                    # self.iface.setActiveLayer(vlayer)
                    # self.iface.zoomToActiveLayer()
                    self.loadedTiles.append(tileTableName)
                else:
                    msgBox = QMessageBox(self)
                    msgBox.setIcon(QMessageBox.Information)
                    msgBox.setWindowTitle(self.windowTitle)
                    msgBox.setText("Impossible to Load table: " + tileTableName
                                   + " into QGIS")
                    msgBox.exec_()
            for np in range(len(pointsFc)):
                ptoIdInTileTable = pointsIdInTileTable[np]
                ptoFc = pointsFc[np]
                ptoSc = pointsSc[np]
                ptoClass = pointsClass[np]
                ptoClassNew = pointsClassNew[np]
                ptoAltitude = pointsAltitude[np]
                ptoRemove = pointsRemoved[np]
                if ptoRemove:
                    ptoClassNew = ptoClass
                ptoTileTableNameId = pointsTilesTableNameId[np]
                tileTableName = tilesTableNamesById[ptoTileTableNameId]
                layerList = QgsProject.instance().mapLayersByName(tileTableName)
                vlayer = layerList[0]
                provider = vlayer.dataProvider()
                fields = provider.fields()
                ptoFeature = QgsFeature()
                ptoPosition = QgsPointXY()
                ptoPosition.setX(ptoFc)
                ptoPosition.setY(ptoSc)
                ptoGeometry = QgsGeometry.fromPointXY(ptoPosition)
                ptoFeature.setGeometry(ptoGeometry)
                ptoFeature.setFields(fields)
                # feature1.setAttribute("heightElip", 60.3559)
                ptoFeature.setAttribute(PCTDefinitions.CONST_LAYER_PCTILES_FIELD_ID_NAME, ptoIdInTileTable)
                ptoFeature.setAttribute("class_new", ptoClassNew)
                ptoFeature.setAttribute("class", ptoClass)
                ptoFeature.setAttribute("altitude", ptoAltitude)
                ptoFeature.setAttribute("removed", ptoRemove)
                featuresByTileTableName[tileTableName].append(ptoFeature)
            for tileTableNameId in tilesTableNamesById:
                tileTableName = tilesTableNamesById[tileTableNameId]
                if len(featuresByTileTableName[tileTableName]) == 0:
                    continue
                layerList = QgsProject.instance().mapLayersByName(tileTableName)
                vlayer = layerList[0]
                provider = vlayer.dataProvider()
                provider.addFeatures(featuresByTileTableName[tileTableName])
                vlayer.updateExtents()
                vlayer.loadNamedStyle(self.qmlPointCloudFileName)
                vlayer.setScaleBasedVisibility(True)
                vlayer.setMinimumScale(self.minimumScale)
                vlayer.setMaximumScale(PCTDefinitions.CONST_MAXIMUM_SCALE)
                vlayer.triggerRepaint()
                # iface.mapCanvas().zoomToFullExtent()

            # cont = 0
            # for value in ret:
            #     if cont == 1:
            #         dictVal = value
            #         for key in dictVal:
            #             dictValue = dictVal[key]
            #             yo = 1
            #         yo = 1
            #     if cont > 1:
            #         val_0 = value[0]
            #         val_1 = value[1]
            #         val_2 = value[2]
            #         val_3 = value[3]
            #         yo = 1
            #     cont = cont + 1

            # tilesTableNames = []
            # cont = 0
            # msg = "Tiles table names:\n"
            # for value in ret:
            #     if cont > 0:
            #         tilesTableNames.append(value)
            #         msg = msg + value
            #         msg = msg + "\n"
            #     cont = cont + 1
            # msgBox = QMessageBox(self)
            # msgBox.setIcon(QMessageBox.Information)
            # msgBox.setWindowTitle(self.windowTitle)
            # msgBox.setText(msg)
            # msgBox.exec_()

        msgBox = QMessageBox(self)
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(self.windowTitle)
        msgBox.setText("Minimum scale: 1/" + str(self.minimumScale))
        msgBox.exec_()
        self.iface.mapCanvas().zoomScale(self.minimumScale-1)
        self.actionSetVisiblePoints()
        return

    def selectNewDatabase(self):
        oldFileName=self.databaseLineEdit.text()
        title="Select New Project File (.sqlite)"
        filters="Project Files (*.sqlite)"
        fileName, _ = QFileDialog.getSaveFileName(self,title,self.path,filters)
        if fileName:
            fileInfo = QFileInfo(fileName)
            self.path = fileInfo.absolutePath()
            self.databaseLineEdit.setText(fileName)
            self.settings.setValue("last_path", self.path)
            self.settings.sync()
        return

    def selectProjectParameters(self):
        projectType = self.projectTypeComboBox.currentText()
        if projectType == PCTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project type before")
            msgBox.exec_()
            return
        ret = self.iPyProject.pctSelectProjectParameters(projectType)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
        return

    def selectPCFs(self):
        previousFiles = self.pointCloudFiles[:] # copia desligada
        dlg = MultipleFileSelectorDialog(self.iface,
                                         self.path,
                                         PCTDefinitions.CONST_SELECT_POINT_CLOUD_FILES_DIALOG_TITLE,
                                         self.pointCloudFilesFileTypes,
                                         self.pointCloudFiles,
                                         self.pointCloudFilesActiveFileExtensions)
        dlg.show() # show the dialog
        result = dlg.exec_() # Run the dialog
        self.path = dlg.getPath()
        self.settings.setValue("last_path",self.path)
        files = dlg.getFiles() # los hay repetidos
        self.pointCloudFiles = []
        self.numberOfPCFsLineEdit.setText("0")
        for file in files:
            fileBaseName = QFileInfo(file).baseName()
            findFile = False
            for pointCloudFile in self.pointCloudFiles:
                if fileBaseName == QFileInfo(pointCloudFile).baseName():
                    findFile = True
                    break
            if not findFile:
                self.pointCloudFiles.append(file)
        self.pointCloudFilesActiveFileExtensions = dlg.getActiveFileExtensions()
        self.numberOfPCFsLineEdit.setText(str(len(self.pointCloudFiles)))
        return

    def selectPostprocessingIPCFs(self):
        previousFiles = self.postprocessingIPCFs[:] # copia desligada
        dlg = MultipleFileSelectorDialog(self.iface,
                                         self.path,
                                         PCTDefinitions.CONST_SELECT_POINT_CLOUD_FILES_DIALOG_TITLE,
                                         self.pointCloudFilesFileTypes,
                                         self.postprocessingIPCFs,
                                         self.pointCloudFilesActiveFileExtensions)
        dlg.show() # show the dialog
        result = dlg.exec_() # Run the dialog
        self.path = dlg.getPath()
        self.settings.setValue("last_path",self.path)
        files = dlg.getFiles() # los hay repetidos
        self.postprocessingIPCFs = []
        self.numberOfPCFsLineEdit.setText("0")
        for file in files:
            fileBaseName = QFileInfo(file).baseName()
            findFile = False
            for pointCloudFile in self.postprocessingIPCFs:
                if fileBaseName == QFileInfo(pointCloudFile).baseName():
                    findFile = True
                    break
            if not findFile:
                self.postprocessingIPCFs.append(file)
        self.pointCloudFilesActiveFileExtensions = dlg.getActiveFileExtensions()
        self.ppToolsNumberOfIPCFsLineEdit.setText(str(len(self.postprocessingIPCFs)))
        return

    def selectPpToolsOutputFile(self):
        oldFileName=self.ppToolsOPCFsOutputFileLineEdit.text()
        title="Select preprocessing tools output file"
        filters="Point Cloud File (*."
        cont = 0
        for fileType in self.pointCloudFilesFileTypes:
            filters+=fileType
            cont = cont + 1
            if cont < len(self.pointCloudFilesFileTypes):
                filters+=";*."
        filters += ";*.tif"
        filters+=")"
        fileName, _ = QFileDialog.getSaveFileName(self,title,self.path,filters)
        if fileName:
            fileInfo = QFileInfo(fileName)
            self.path = fileInfo.absolutePath()
            self.ppToolsOPCFsOutputFileLineEdit.setText(fileName)
            self.settings.setValue("last_path", self.path)
            self.settings.sync()
        return

    def selectPpToolsOutpufFilesPrefix(self):
        oldText = self.ppToolsOPCFsPrefixLineEdit.text()
        label = "Input prefix for output preprocessed point cloud files:"
        title = PCTDefinitions.CONST_PROGRAM_TITLE
        [text, ok] = QInputDialog.getText(self, title, label, QLineEdit.Normal, oldText)
        if ok and text:
            text = text.strip()
            if not text == oldText:
                self.ppToolsOPCFsPrefixLineEdit.setText(text)
        return

    def selectPpToolsOutpufFilesSuffix(self):
        oldText = self.ppToolsOPCFsSuffixLineEdit.text()
        label = "Input suffix for output preprocessed point cloud files:"
        title = PCTDefinitions.CONST_PROGRAM_TITLE
        [text, ok] = QInputDialog.getText(self, title, label, QLineEdit.Normal, oldText)
        if ok and text:
            text = text.strip()
            if not text == oldText:
                self.ppToolsOPCFsSuffixLineEdit.setText(text)
        return

    def selectPpToolsOutputPath(self):
        strDir = QFileDialog.getExistingDirectory(self,"Select directory",self.path,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            self.settings.setValue("lasttools_path", strDir)
            self.settings.sync()
            self.ppToolsOPCFsOutputPathLineEdit.setText(strDir)
        return

    def selectProjectManagerOutputPath(self):
        strDir = QFileDialog.getExistingDirectory(self,"Select directory", self.projectManagerOutputPath,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            ret = self.iPyProject.pctSetProjectManagerOutputPath(self.projectManagerOutputPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.pmOutputPathLineEdit.setText("")
                self.projectManagerOutputPath = None
                return
            self.projectManagerOutputPath = strDir
            self.settings.setValue("project_management_output_path", self.projectManagerOutputPath)
            self.settings.sync()
            self.pmOutputPathLineEdit.setText(strDir)
        return

    def selectProjectManagerTemporalPath(self):
        strDir = QFileDialog.getExistingDirectory(self,"Select directory", self.projectManagerTemporalPath,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            ret = self.iPyProject.pctSetProjectManagerTemporalPath(self.projectManagerTemporalPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.pmTemporalPathLineEdit.setText("")
                self.projectManagerTemporalPath = None
                return
            self.projectManagerTemporalPath = strDir
            self.settings.setValue("project_management_temporal_path", self.projectManagerTemporalPath)
            self.settings.sync()
            self.pmTemporalPathLineEdit.setText(strDir)
        return

    def selectProject(self):
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)
        if self.connectionFileName:
            if not self.connectionFileName in self.connections:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("No connection for: " + str(self.connectionFileName))
                msgBox.exec_()
                return
            index = self.projectsComboBox.findText(self.connectionFileName)
            if index >= 0:
                self.projectsComboBox.setCurrentIndex(index)
        projectFileName = self.projectsComboBox.currentText()
        if projectFileName == PCTDefinitions.CONST_NO_COMBO_SELECT:
            self.projectManagementTabWidget.setEnabled(True)
            self.projectManagementTabWidget.setTabEnabled(0, True)
            self.projectManagementTabWidget.setTabEnabled(1, False)
            self.projectManagementTabWidget.setTabEnabled(2, False)
            self.projectManagementTabWidget.setCurrentIndex(0)
            if self.dbFileName:
                self.closeProject()
        else:
            self.projectManagementTabWidget.setEnabled(False)
            # self.projectManagementTabWidget.setTabEnabled(0, False)
            # self.projectManagementTabWidget.setTabEnabled(1, False)
            # self.projectManagementTabWidget.setTabEnabled(2, False)
            self.projectManagementTabWidget.setCurrentIndex(1)
            self.openProjectPushButton.setEnabled(True)
            self.closeProjectPushButton.setEnabled(False)
        if self.connectionFileName:
            self.openProject()
        return

    def selectProjectType(self):
        projectType = self.projectTypeComboBox.currentText()
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Project type: "+projectType)
        # msgBox.exec_()
        return

    def selectReclassificationConfusionMatrixReportProcess(self):
        outputFile = self.reclassificationConfusionMatrixReportOutputFileLineEdit.text()
        if not outputFile:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select output file")
            msgBox.exec_()
            return
        selectedClasses = self.reclassificationConfusionMatrixReportValidSelectClasses
        if self.reclassificationConfussionMatrixReportSelectedClassesRadioButton.isChecked():
            selectedClasses = []
            strSelectedClasses = self.reclassificationConfusionMatrixReportSelectClassesLineEdit.text()
            values = strSelectedClasses.split(';')
            for selectedClass in values:
                selectedClasses.append(int(selectedClass))
        ret = self.iPyProject.pctProcessReclassificationConfusionMatrixReport(self.dbFileName,
                                                                              selectedClasses,
                                                                              outputFile)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        else:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process completed successfully")
            msgBox.exec_()
        return

    def selectReclassificationConfusionMatrixSelectClasses(self):
        oldValue = self.reclassificationConfusionMatrixReportSelectClassesLineEdit.text()
        text, ok = QInputDialog.getText(self, 'Input selected classes', 'Selected classes, (integers separated by ;):',QLineEdit.Normal,oldValue)
        if ok:
            values = text.split(';')
            validSelectedClasses = []
            for selectedClass in values:
                if not selectedClass.isdigit():
                    continue
                value = int(selectedClass)
                if value in validSelectedClasses:
                    continue
                if not value in self.reclassificationConfusionMatrixReportValidSelectClasses:
                    continue
                validSelectedClasses.append(selectedClass)
            if len(validSelectedClasses) < 1:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Invalid selection")
                msgBox.exec_()
                return
            newValue = ''
            cont = 0
            for validSelectedClass in validSelectedClasses:
                newValue += str(validSelectedClass)
                cont = cont + 1
                if cont<len(validSelectedClasses):
                    newValue += ';'
            self.reclassificationConfusionMatrixReportSelectClassesLineEdit.setText(newValue)
        return

    def selectReclassificationConfusionMatrixReportFile(self):
        oldFileName = self.reclassificationConfusionMatrixReportOutputFileLineEdit.text()
        title="Select reclassification confusion matrix report file"
        filters="Txt (*.txt)"
        fileName, _ = QFileDialog.getSaveFileName(self,title,self.path,filters)
        if fileName:
            fileInfo = QFileInfo(fileName)
            self.path = fileInfo.absolutePath()
            self.reclassificationConfusionMatrixReportOutputFileLineEdit.setText(fileName)
            self.settings.setValue("last_path", self.path)
            self.settings.sync()
        return

    def selectReclassificationConfusionMatrixSelectedClasses(self):
        if self.reclassificationConfussionMatrixReportSelectedClassesRadioButton.isChecked():
            self.reclassificationConfusionMatrixReportSelectClassesLineEdit.setEnabled(True)
            self.reclassificationConfusionMatrixReportSelectClassesPushButton.setEnabled(True)
        else:
            self.reclassificationConfusionMatrixReportSelectClassesLineEdit.setEnabled(False)
            self.reclassificationConfusionMatrixReportSelectClassesPushButton.setEnabled(False)
        return

    def selectReclassificationConfusionMatrixReportAllClasses(self):
        if self.reclassificationConfussionMatrixReportSelectedClassesRadioButton.isChecked():
            self.reclassificationConfusionMatrixReportSelectClassesLineEdit.setEnabled(True)
            self.reclassificationConfusionMatrixReportSelectClassesPushButton.setEnabled(True)
        else:
            self.reclassificationConfusionMatrixReportSelectClassesLineEdit.setEnabled(False)
            self.reclassificationConfusionMatrixReportSelectClassesPushButton.setEnabled(False)
        return

    def selectRois(self):
        previousFiles = self.roisShapefiles[:] # copia desligada
        dlg = MultipleFileSelectorDialog(self.iface,
                                         self.path,
                                         PCTDefinitions.CONST_SELECT_ROIS_SHAPEFILES_DIALOG_TITLE,
                                         self.roisFileTypes,
                                         self.roisShapefiles,
                                         self.roisFilesActiveFileExtensions)
        dlg.show() # show the dialog
        result = dlg.exec_() # Run the dialog
        self.path = dlg.getPath()
        self.settings.setValue("last_path",self.path)
        files = dlg.getFiles() # los hay repetidos
        self.roisShapefiles = []
        self.numberOfRoisLineEdit.setText("0")
        for file in files:
            fileBaseName = QFileInfo(file).baseName()
            findFile = False
            for roiFile in self.roisShapefiles:
                if fileBaseName == QFileInfo(roiFile).baseName():
                    findFile = True
                    break
            if not findFile:
                self.roisShapefiles.append(file)
        self.roisFilesActiveFileExtensions = dlg.getActiveFileExtensions()
        self.numberOfRoisLineEdit.setText(str(len(self.roisShapefiles)))
        return

    def toClass0(self):
        newClass = 0
        self.actionWithSelectedPoints(newClass)

    def toClass1(self):
        newClass = 1
        self.actionWithSelectedPoints(newClass)

    def toClass12(self):
        newClass = 12
        self.actionWithSelectedPoints(newClass)

    def toClass2(self):
        newClass = 2
        self.actionWithSelectedPoints(newClass)

    def toClass3(self):
        newClass = 3
        self.actionWithSelectedPoints(newClass)

    def toClass4(self):
        newClass = 4
        self.actionWithSelectedPoints(newClass)

    def toClass5(self):
        newClass = 5
        self.actionWithSelectedPoints(newClass)

    def toClass6(self):
        newClass = 6
        self.actionWithSelectedPoints(newClass)

    def toClass7(self):
        newClass = 7
        self.actionWithSelectedPoints(newClass)

    def toClass9(self):
        newClass = 9
        self.actionWithSelectedPoints(newClass)

    def runProcessList(self):
        if len(self.processList) == 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process list is empty")
            msgBox.exec_()
            return
        title = PCTDefinitions.CONST_RUN_PROCESS_LIST_DIALOG_TITLE
        ret = self.iPyProject.pctRunProcessList(self.processList, title)
        # if ret[0] == "False":
        #     msgBox = QMessageBox(self)
        #     msgBox.setIcon(QMessageBox.Information)
        #     msgBox.setWindowTitle(self.windowTitle)
        #     msgBox.setText("Error:\n"+ret[1])
        #     msgBox.exec_()
        #     return
        # else:
        #     msgBox = QMessageBox(self)
        #     msgBox.setIcon(QMessageBox.Information)
        #     msgBox.setWindowTitle(self.windowTitle)
        #     msgBox.setText("Process completed successfully")
        #     msgBox.exec_()
        # return

    def selectAllClasses(self):
        newClass = None
        self.actionWithSelectedPoints(newClass)

    def toOriginalClass(self):
        self.allClassesPushButton.setEnabled(True)
        return

    def unenableAllClasses(self):
        self.allClassesPushButton.setEnabled(False)
        return

    def unloadAllTiles(self):
        if self.layerTreePCTiles:
            root = self.layerTreeProject
            self.removeGroup(root,self.layerTreePCTilesName)
            self.layerTreePCTiles = None
            self.layerTreePCTilesName = None
            self.loadedTiles = []
            self.iface.mapCanvas().refresh()
        return

    def view3DSelectedPoints(self):
        wktGeom = None
        tilesTableNamesById = None  # QMap < int, QString > tilesTableNamesById;
        pointsTilesTableNameId = None  # QVector < int > pointsTilesTableNameId;
        pointsIdInTileTable = None  # QVector < int > pointsIdInTileTable;
        if self.toolRectangle3D:
            wktGeom = self.toolRectangle3D.getWktGeomeetry()
            projectCrs = QgsProject.instance().crs()
            projectCrsEpsgCode = -1
            projectCrsProj4 = ""
            projectCrsAuthId = projectCrs.authid()
            if "EPSG" in projectCrsAuthId:
                projectCrsEpsgCode = int(projectCrsAuthId.replace("EPSG:", ""))
            projectCrsProj4 = projectCrs.toProj4()
            # mapCanvasCrsEpsgCode = int(self.iface.mapCanvas().mapRenderer().destinationCrs().authid().replace("EPSG:",""))
            # mapCanvasCrs = self.iface.mapCanvas().mapRenderer().destinationCrs()
            ret = self.iPyProject.pctView3dFromWktGeometry(self.dbFileName,
                                                           wktGeom,
                                                           projectCrsEpsgCode,
                                                           projectCrsProj4)
            self.toolRectangle3D.endSelection.disconnect(self.view3DSelectedPoints)
            self.toolRectangle3D.rubberBand.hide()
            self.toolRectangle3D = None
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                return
            if not self.storePointsData:
                if not self.loadedTiles:
                    self.iface.mapCanvas().refresh()
                    self.actionSetVisiblePoints()
                    self.iface.mapCanvas().refresh()
                    self.actionSetVisiblePoints()
                    return
                tilesTableNamesById = ret[1]  # QMap < int, QString > tilesTableNamesById;
                pointsTilesTableNameId = ret[2]  # QVector < int > pointsTilesTableNameId;
                pointsIdInTileTable = ret[3]  # QVector < int > pointsIdInTileTable;
        elif self.toolPolygon3D:
            wktGeom = self.toolPolygon3D.getWktGeomeetry()
            projectCrs = QgsProject.instance().crs()
            projectCrsEpsgCode = -1
            projectCrsProj4 = ""
            projectCrsAuthId = projectCrs.authid()
            if "EPSG" in projectCrsAuthId:
                projectCrsEpsgCode = int(projectCrsAuthId.replace("EPSG:", ""))
            projectCrsProj4 = projectCrs.toProj4()
            # mapCanvasCrsEpsgCode = int(self.iface.mapCanvas().mapRenderer().destinationCrs().authid().replace("EPSG:",""))
            # mapCanvasCrs = self.iface.mapCanvas().mapRenderer().destinationCrs()
            ret = self.iPyProject.pctView3dFromWktGeometry(self.dbFileName,
                                                           wktGeom,
                                                           projectCrsEpsgCode,
                                                           projectCrsProj4)
            self.toolPolygon3D.endSelection.disconnect(self.view3DSelectedPoints)
            self.toolPolygon3D.rubberBand.hide()
            self.toolPolygon3D.rubberBand.reset(QgsWkbTypes.PolygonGeometry)
            self.toolPolygon3D.reset()
            self.toolPolygon3D = None
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                return
            if not self.storePointsData:
                if not self.loadedTiles:
                    self.iface.mapCanvas().refresh()
                    self.actionSetVisiblePoints()
                    self.iface.mapCanvas().refresh()
                    self.actionSetVisiblePoints()
                    return
                tilesTableNamesById = ret[1]  # QMap < int, QString > tilesTableNamesById;
                pointsTilesTableNameId = ret[2]  # QVector < int > pointsTilesTableNameId;
                pointsIdInTileTable = ret[3]  # QVector < int > pointsIdInTileTable;
        elif self.toolFreehand3D:
            wktGeom = self.toolFreehand3D.getWktGeomeetry()
            projectCrs = QgsProject.instance().crs()
            projectCrsEpsgCode = -1
            projectCrsProj4 = ""
            projectCrsAuthId = projectCrs.authid()
            if "EPSG" in projectCrsAuthId:
                projectCrsEpsgCode = int(projectCrsAuthId.replace("EPSG:", ""))
            projectCrsProj4 = projectCrs.toProj4()
            # mapCanvasCrsEpsgCode = int(self.iface.mapCanvas().mapRenderer().destinationCrs().authid().replace("EPSG:",""))
            # mapCanvasCrs = self.iface.mapCanvas().mapRenderer().destinationCrs()
            ret = self.iPyProject.pctView3dFromWktGeometry(self.dbFileName,
                                                           wktGeom,
                                                           projectCrsEpsgCode,
                                                           projectCrsProj4)
            self.toolFreehand3D.endSelection.disconnect(self.view3DSelectedPoints)
            self.toolFreehand3D.rubberBand.hide()
            self.toolFreehand3D.rubberBand.reset(QgsWkbTypes.PolygonGeometry)
            self.toolFreehand3D.reset()
            self.toolFreehand3D = None
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                return
            if not self.storePointsData:
                if not self.loadedTiles:
                    self.iface.mapCanvas().refresh()
                    self.actionSetVisiblePoints()
                    self.iface.mapCanvas().refresh()
                    self.actionSetVisiblePoints()
                    return
                tilesTableNamesById = ret[1]  # QMap < int, QString > tilesTableNamesById;
                pointsTilesTableNameId = ret[2]  # QVector < int > pointsTilesTableNameId;
                pointsIdInTileTable = ret[3]  # QVector < int > pointsIdInTileTable;
        if not self.storePointsData:
            if not self.loadedTiles:
                self.iface.mapCanvas().refresh()
                self.actionSetVisiblePoints()
                return
            numberOfUpdateddPoints = len(pointsIdInTileTable)
            updatedPointsIdByTableName = {}
            if numberOfUpdateddPoints > 0:
                cont = 0
                for pointIdInTileTable in pointsIdInTileTable:
                    pointTileTableNameId = pointsTilesTableNameId[cont]
                    tileTableName = tilesTableNamesById[pointTileTableNameId]
                    if not tileTableName in updatedPointsIdByTableName:
                        updatedPointsIdByTableName[tileTableName] = []
                    updatedPointsIdByTableName[tileTableName].append(pointIdInTileTable)
                    cont = cont + 1
                ret = self.iPyProject.pctGetSelectedPoints(self.dbFileName,
                                                           updatedPointsIdByTableName)
                if ret[0] == "False":
                    msgBox = QMessageBox(self)
                    msgBox.setIcon(QMessageBox.Information)
                    msgBox.setWindowTitle(self.windowTitle)
                    msgBox.setText("Error:\n" + ret[1])
                    msgBox.exec_()
                    return
                tilesTableNamesById = ret[1]  # QMap < int, QString > tilesTableNamesById;
                pointsTilesTableNameId = ret[2]  # QVector < int > pointsTilesTableNameId;
                pointsIdInTileTable = ret[3]  # QVector < int > pointsIdInTileTable;
                # pointsGpsTime = ret[4]  # QVector < double > pointsGpsTime;
                # pointsBlue = ret[5]  # QVector < int > pointsBlue;
                # pointsRed = ret[6]  # QVector < int > pointsRed;
                # pointsGreen = ret[7]  # QVector < int > pointsGreen;
                # pointsNir = ret[8]  # QVector < int > pointsNir;
                # pointsIntensity = ret[9]  # QVector < int > pointsIntensity;
                # pointsReturns = ret[10]  # QVector < int > pointsReturns;
                # pointsReturn = ret[11]  # QVector < int > pointsReturn;
                pointsClass = ret[12]  # QVector < int > pointsClass;
                pointsClassNew = ret[13]  # QVector < int > pointsClassNew;
                pointsRemoved = ret[14]  # QVector < bool > pointsRemoved;
                # pointsFc = ret[15]  # QVector < double > pointsFc;
                # pointsSc = ret[16]  # QVector < double > pointsSc;
                # pointsHeight = ret[17]  # QVector < double > pointsHeight;
                # pointsAltitude = ret[18]  # QVector < double > pointsAltitude;
                layersToRepaint = []
                for np in range(len(pointsClass)):
                    ptoIdInTileTable = pointsIdInTileTable[np]
                    ptoTileTableNameId = pointsTilesTableNameId[np]
                    tileTableName = tilesTableNamesById[ptoTileTableNameId]
                    layerList = QgsProject.instance().mapLayersByName(tileTableName)
                    vlayer = layerList[0]
                    requestExpression = QgsExpression( "\""+PCTDefinitions.CONST_LAYER_PCTILES_FIELD_ID_NAME+"\" = " + str(ptoIdInTileTable))
                    # requestExpression ? QgsExpression(" \"id\" = '{}' ".format(myVariable))
                    selection = vlayer.getFeatures(QgsFeatureRequest(requestExpression))
                    feature = None
                    for vfeature in selection: # solo habra una
                        feature = vfeature
                    # ptoFc = pointsFc[np]
                    # ptoSc = pointsSc[np]
                    ptoClass = pointsClass[np]
                    ptoClassNew = pointsClassNew[np]
                    # ptoAltitude = pointsAltitude[np]
                    ptoRemove = pointsRemoved[np]
                    if feature["removed"] == ptoRemove:
                        if ptoClassNew == feature["class_new"]:
                            continue
                    if ptoRemove:
                        ptoClassNew = ptoClass
                    if not vlayer in layersToRepaint:
                        vlayer.startEditing()
                        layersToRepaint.append(vlayer)
                    feature.setAttribute("class_new", ptoClassNew)
                    if feature["removed"] != ptoRemove:
                        if ptoRemove:
                            feature.setAttribute("removed",True)
                        else:
                            feature.setAttribute("removed",False)
                    vlayer.updateFeature(feature)
                for vlayer in layersToRepaint:
                    vlayer.commitChanges()
                    vlayer.triggerRepaint()

            # geom = QgsGeometry.fromWkt(wktGeom)
            # # box = geom.boundingBox()
            # # r = QgsRectangle(minFc,minSc,maxFc,maxSc)
            # r = geom.boundingBox()
            # layers = self.iface.mapCanvas().layers()
            # for layer in layers:
            #     layerName = layer.name()
            #     if not layerName in self.loadedTiles:
            #         continue
            #     if layer.type() == QgsMapLayer.VectorLayer:
            #         # Luego filtro x name
            #         bbRect = self.iface.mapCanvas().mapSettings().mapToLayerCoordinates(layer, r)
            #         layer.selectByRect(bbRect, True)
            # [selectedPointsIdByTableName, numberOfSelectedPoints] = self.getSelectedPointsIdByTableName()
            # if numberOfSelectedPoints > 0:
            #     ret = self.iPyProject.pctGetSelectedPoints(self.dbFileName,
            #                                                selectedPointsIdByTableName)
            #     if ret[0] == "False":
            #         msgBox = QMessageBox(self)
            #         msgBox.setIcon(QMessageBox.Information)
            #         msgBox.setWindowTitle(self.windowTitle)
            #         msgBox.setText("Error:\n" + ret[1])
            #         msgBox.exec_()
            #         return
            #     tilesTableNamesById = ret[1]  # QMap < int, QString > tilesTableNamesById;
            #     pointsTilesTableNameId = ret[2]  # QVector < int > pointsTilesTableNameId;
            #     nov = len(pointsTilesTableNameId)
            #     pointsIdInTileTable = ret[3]  # QVector < int > pointsIdInTileTable;
            #     # pointsGpsTime = ret[4]  # QVector < double > pointsGpsTime;
            #     # pointsBlue = ret[5]  # QVector < int > pointsBlue;
            #     # pointsRed = ret[6]  # QVector < int > pointsRed;
            #     # pointsGreen = ret[7]  # QVector < int > pointsGreen;
            #     # pointsNir = ret[8]  # QVector < int > pointsNir;
            #     # pointsIntensity = ret[9]  # QVector < int > pointsIntensity;
            #     # pointsReturns = ret[10]  # QVector < int > pointsReturns;
            #     # pointsReturn = ret[11]  # QVector < int > pointsReturn;
            #     pointsClass = ret[12]  # QVector < int > pointsClass;
            #     pointsClassNew = ret[13]  # QVector < int > pointsClassNew;
            #     pointsRemoved = ret[14]  # QVector < bool > pointsRemoved;
            #     # pointsFc = ret[15]  # QVector < double > pointsFc;
            #     # pointsSc = ret[16]  # QVector < double > pointsSc;
            #     # pointsHeight = ret[17]  # QVector < double > pointsHeight;
            #     # pointsAltitude = ret[18]  # QVector < double > pointsAltitude;
            #     layersToRepaint = []
            #     for np in range(len(pointsClass)):
            #         ptoIdInTileTable = pointsIdInTileTable[np]
            #         ptoTileTableNameId = pointsTilesTableNameId[np]
            #         tileTableName = tilesTableNamesById[ptoTileTableNameId]
            #         layerList = QgsProject.instance().mapLayersByName(tileTableName)
            #         vlayer = layerList[0]
            #         requestExpression = QgsExpression( "\""+PCTDefinitions.CONST_LAYER_PCTILES_FIELD_ID_NAME+"\" = " + str(ptoIdInTileTable))
            #         # requestExpression ? QgsExpression(" \"id\" = '{}' ".format(myVariable))
            #         selection = vlayer.getFeatures(QgsFeatureRequest(requestExpression))
            #         feature = None
            #         for vfeature in selection: # solo habra una
            #             feature = vfeature
            #         # ptoFc = pointsFc[np]
            #         # ptoSc = pointsSc[np]
            #         ptoClass = pointsClass[np]
            #         ptoClassNew = pointsClassNew[np]
            #         # ptoAltitude = pointsAltitude[np]
            #         ptoRemove = pointsRemoved[np]
            #         if feature["removed"] == ptoRemove:
            #             if ptoClassNew == feature["class_new"]:
            #                 continue
            #         if ptoRemove:
            #             ptoClassNew = ptoClass
            #         if not vlayer in layersToRepaint:
            #             vlayer.startEditing()
            #             layersToRepaint.append(vlayer)
            #         feature.setAttribute("class_new", ptoClassNew)
            #         if feature["removed"] != ptoRemove:
            #             if ptoRemove:
            #                 feature.setAttribute("removed",True)
            #             else:
            #                 feature.setAttribute("removed",False)
            #         vlayer.updateFeature(feature)
            #     for vlayer in layersToRepaint:
            #         vlayer.commitChanges()
            #         vlayer.triggerRepaint()
        self.iface.mapCanvas().refresh()
        self.actionSetVisiblePoints()
        return

    def view3dMapCanvas(self):
        mapCanvasExtend = self.iface.mapCanvas().extent()
        maxFc = mapCanvasExtend.xMaximum()
        maxSc = mapCanvasExtend.yMaximum()
        minFc = mapCanvasExtend.xMinimum()
        minSc = mapCanvasExtend.yMinimum()
        mapCanvasWkt = 'POLYGON((' + str(minFc)+ ' '+str(maxSc) + ',' \
                        + str(maxFc) + ' ' + str(maxSc) + ',' \
                        + str(maxFc) + ' ' + str(minSc) + ',' \
                        + str(minFc) + ' ' + str(minSc) + ',' \
                        + str(minFc) + ' ' + str(maxSc) + '))'
        # mapCanvasGeometry = ogr.CreateGeometryFromWkt(mapCanvasWkt)
        # epsgCode = int(self.lidarFilesCrs.authid().replace("EPSG:",""))
        projectCrs = QgsProject.instance().crs()
        projectCrsEpsgCode = -1
        projectCrsProj4 = ""
        projectCrsAuthId = projectCrs.authid()
        if "EPSG" in projectCrsAuthId:
            projectCrsEpsgCode = int(projectCrsAuthId.replace("EPSG:",""))
        projectCrsProj4 = projectCrs.toProj4()
        # mapCanvasCrsEpsgCode = int(self.iface.mapCanvas().mapRenderer().destinationCrs().authid().replace("EPSG:",""))
        # mapCanvasCrs = self.iface.mapCanvas().mapRenderer().destinationCrs()
        ret = self.iPyProject.pctView3dFromWktGeometry(self.dbFileName,
                                                       mapCanvasWkt,
                                                       projectCrsEpsgCode,
                                                       projectCrsProj4)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        if not self.storePointsData:
            if not self.loadedTiles:
                self.iface.mapCanvas().refresh()
                self.actionSetVisiblePoints()
                return
            tilesTableNamesById = ret[1]  # QMap < int, QString > tilesTableNamesById;
            pointsTilesTableNameId = ret[2]  # QVector < int > pointsTilesTableNameId;
            pointsIdInTileTable = ret[3]  # QVector < int > pointsIdInTileTable;
            numberOfUpdateddPoints = len(pointsIdInTileTable)
            updatedPointsIdByTableName = {}
            if numberOfUpdateddPoints > 0:
                cont = 0
                for pointIdInTileTable in pointsIdInTileTable:
                    pointTileTableNameId = pointsTilesTableNameId[cont]
                    tileTableName = tilesTableNamesById[pointTileTableNameId]
                    if not tileTableName in updatedPointsIdByTableName:
                        updatedPointsIdByTableName[tileTableName] = []
                    updatedPointsIdByTableName[tileTableName].append(pointIdInTileTable)
                    cont = cont + 1
                ret = self.iPyProject.pctGetSelectedPoints(self.dbFileName,
                                                           updatedPointsIdByTableName)
                if ret[0] == "False":
                    msgBox = QMessageBox(self)
                    msgBox.setIcon(QMessageBox.Information)
                    msgBox.setWindowTitle(self.windowTitle)
                    msgBox.setText("Error:\n" + ret[1])
                    msgBox.exec_()
                    return
                tilesTableNamesById = ret[1]  # QMap < int, QString > tilesTableNamesById;
                pointsTilesTableNameId = ret[2]  # QVector < int > pointsTilesTableNameId;
                pointsIdInTileTable = ret[3]  # QVector < int > pointsIdInTileTable;
                # pointsGpsTime = ret[4]  # QVector < double > pointsGpsTime;
                # pointsBlue = ret[5]  # QVector < int > pointsBlue;
                # pointsRed = ret[6]  # QVector < int > pointsRed;
                # pointsGreen = ret[7]  # QVector < int > pointsGreen;
                # pointsNir = ret[8]  # QVector < int > pointsNir;
                # pointsIntensity = ret[9]  # QVector < int > pointsIntensity;
                # pointsReturns = ret[10]  # QVector < int > pointsReturns;
                # pointsReturn = ret[11]  # QVector < int > pointsReturn;
                pointsClass = ret[12]  # QVector < int > pointsClass;
                pointsClassNew = ret[13]  # QVector < int > pointsClassNew;
                pointsRemoved = ret[14]  # QVector < bool > pointsRemoved;
                # pointsFc = ret[15]  # QVector < double > pointsFc;
                # pointsSc = ret[16]  # QVector < double > pointsSc;
                # pointsHeight = ret[17]  # QVector < double > pointsHeight;
                # pointsAltitude = ret[18]  # QVector < double > pointsAltitude;
                layersToRepaint = []
                for np in range(len(pointsClass)):
                    ptoIdInTileTable = pointsIdInTileTable[np]
                    ptoTileTableNameId = pointsTilesTableNameId[np]
                    tileTableName = tilesTableNamesById[ptoTileTableNameId]
                    layerList = QgsProject.instance().mapLayersByName(tileTableName)
                    vlayer = layerList[0]
                    requestExpression = QgsExpression( "\""+PCTDefinitions.CONST_LAYER_PCTILES_FIELD_ID_NAME+"\" = " + str(ptoIdInTileTable))
                    # requestExpression ? QgsExpression(" \"id\" = '{}' ".format(myVariable))
                    selection = vlayer.getFeatures(QgsFeatureRequest(requestExpression))
                    feature = None
                    for vfeature in selection: # solo habra una
                        feature = vfeature
                    # ptoFc = pointsFc[np]
                    # ptoSc = pointsSc[np]
                    ptoClass = pointsClass[np]
                    ptoClassNew = pointsClassNew[np]
                    # ptoAltitude = pointsAltitude[np]
                    ptoRemove = pointsRemoved[np]
                    if feature["removed"] == ptoRemove:
                        if ptoClassNew == feature["class_new"]:
                            continue
                    if ptoRemove:
                        ptoClassNew = ptoClass
                    if not vlayer in layersToRepaint:
                        vlayer.startEditing()
                        layersToRepaint.append(vlayer)
                    feature.setAttribute("class_new", ptoClassNew)
                    if feature["removed"] != ptoRemove:
                        if ptoRemove:
                            feature.setAttribute("removed",True)
                        else:
                            feature.setAttribute("removed",False)
                    vlayer.updateFeature(feature)
                for vlayer in layersToRepaint:
                    vlayer.commitChanges()
                    vlayer.triggerRepaint()


            # r = QgsRectangle(minFc,minSc,maxFc,maxSc)
            # layers = self.iface.mapCanvas().layers()
            # for layer in layers:
            #     layerName = layer.name()
            #     if not layerName in self.loadedTiles:
            #         continue
            #     if layer.type() == QgsMapLayer.VectorLayer:
            #         # Luego filtro x name
            #         bbRect = self.iface.mapCanvas().mapSettings().mapToLayerCoordinates(layer, r)
            #         layer.selectByRect(bbRect, True)
            # [selectedPointsIdByTableName, numberOfSelectedPoints] = self.getSelectedPointsIdByTableName()
            # if numberOfSelectedPoints > 0:
            #     ret = self.iPyProject.pctGetSelectedPoints(self.dbFileName,
            #                                                selectedPointsIdByTableName)
            #     if ret[0] == "False":
            #         msgBox = QMessageBox(self)
            #         msgBox.setIcon(QMessageBox.Information)
            #         msgBox.setWindowTitle(self.windowTitle)
            #         msgBox.setText("Error:\n" + ret[1])
            #         msgBox.exec_()
            #         return
            #     tilesTableNamesById = ret[1]  # QMap < int, QString > tilesTableNamesById;
            #     pointsTilesTableNameId = ret[2]  # QVector < int > pointsTilesTableNameId;
            #     nov = len(pointsTilesTableNameId)
            #     pointsIdInTileTable = ret[3]  # QVector < int > pointsIdInTileTable;
            #     # pointsGpsTime = ret[4]  # QVector < double > pointsGpsTime;
            #     # pointsBlue = ret[5]  # QVector < int > pointsBlue;
            #     # pointsRed = ret[6]  # QVector < int > pointsRed;
            #     # pointsGreen = ret[7]  # QVector < int > pointsGreen;
            #     # pointsNir = ret[8]  # QVector < int > pointsNir;
            #     # pointsIntensity = ret[9]  # QVector < int > pointsIntensity;
            #     # pointsReturns = ret[10]  # QVector < int > pointsReturns;
            #     # pointsReturn = ret[11]  # QVector < int > pointsReturn;
            #     pointsClass = ret[12]  # QVector < int > pointsClass;
            #     pointsClassNew = ret[13]  # QVector < int > pointsClassNew;
            #     pointsRemoved = ret[14]  # QVector < bool > pointsRemoved;
            #     # pointsFc = ret[15]  # QVector < double > pointsFc;
            #     # pointsSc = ret[16]  # QVector < double > pointsSc;
            #     # pointsHeight = ret[17]  # QVector < double > pointsHeight;
            #     # pointsAltitude = ret[18]  # QVector < double > pointsAltitude;
            #     layersToRepaint = []
            #     for np in range(len(pointsClass)):
            #         ptoIdInTileTable = pointsIdInTileTable[np]
            #         ptoTileTableNameId = pointsTilesTableNameId[np]
            #         tileTableName = tilesTableNamesById[ptoTileTableNameId]
            #         layerList = QgsProject.instance().mapLayersByName(tileTableName)
            #         vlayer = layerList[0]
            #         requestExpression = QgsExpression( "\""+PCTDefinitions.CONST_LAYER_PCTILES_FIELD_ID_NAME+"\" = " + str(ptoIdInTileTable))
            #         # requestExpression ? QgsExpression(" \"id\" = '{}' ".format(myVariable))
            #         selection = vlayer.getFeatures(QgsFeatureRequest(requestExpression))
            #         feature = None
            #         for vfeature in selection: # solo habra una
            #             feature = vfeature
            #         # ptoFc = pointsFc[np]
            #         # ptoSc = pointsSc[np]
            #         ptoClass = pointsClass[np]
            #         ptoClassNew = pointsClassNew[np]
            #         # ptoAltitude = pointsAltitude[np]
            #         ptoRemove = pointsRemoved[np]
            #         if feature["removed"] == ptoRemove:
            #             if ptoClassNew == feature["class_new"]:
            #                 continue
            #         if ptoRemove:
            #             ptoClassNew = ptoClass
            #         if not vlayer in layersToRepaint:
            #             vlayer.startEditing()
            #             layersToRepaint.append(vlayer)
            #         feature.setAttribute("class_new", ptoClassNew)
            #         if feature["removed"] != ptoRemove:
            #             if ptoRemove:
            #                 feature.setAttribute("removed",True)
            #             else:
            #                 feature.setAttribute("removed",False)
            #         vlayer.updateFeature(feature)
            #     for vlayer in layersToRepaint:
            #         vlayer.commitChanges()
            #         vlayer.triggerRepaint()
        return